use regex::Regex;
use serde_json::{Map, Number, Value};
use std::collections::HashMap;

use crate::convert::helpers::{export_name, lower_first};
use crate::convert::json_utils::{looks_integer, ordered_keys};

pub fn json_value_to_go(value: &Value) -> String {
    let mut output = String::new();
    output.push_str("type AutoGenerated ");
    output.push_str(&render_type(value));
    output.push('\n');
    output
}

fn render_type(value: &Value) -> String {
    match value {
        Value::Object(map) => render_struct(map),
        Value::Array(items) => format!("[]{}", render_array_element(items)),
        Value::Number(num) => {
            if looks_integer(num) {
                "int".into()
            } else {
                "float64".into()
            }
        }
        Value::String(_) => "string".into(),
        Value::Bool(_) => "bool".into(),
        Value::Null => "interface{}".into(),
    }
}

fn render_struct(map: &Map<String, Value>) -> String {
    let mut out = String::new();
    out.push_str("struct {\n");
    let mut used_names: HashMap<String, usize> = HashMap::new();
    for key in ordered_keys(map) {
        if let Some(val) = map.get(&key) {
            let mut field_name = export_name(&key);
            if field_name.is_empty() {
                field_name = "Field".into();
            }
            let count = used_names.entry(field_name.clone()).or_insert(0);
            if *count > 0 {
                field_name = format!("{}{}", field_name, *count + 1);
            }
            *count += 1;
            let field_type = render_type(val);
            out.push_str(&format!(
                "\t{} {} `json:\"{}\"`\n",
                field_name, field_type, key
            ));
        }
    }
    out.push('}');
    out
}

fn render_array_element(items: &[Value]) -> String {
    let mut element: Option<String> = None;
    for item in items {
        if item.is_null() {
            continue;
        }
        let ty = render_type(item);
        if let Some(existing) = &element {
            if existing != &ty {
                return "interface{}".into();
            }
        } else {
            element = Some(ty);
        }
    }
    element.unwrap_or_else(|| "interface{}".into())
}

pub fn go_struct_to_value(src: &str) -> Result<Value, String> {
    let defs = parse_go_structs(src)?;
    if defs.is_empty() {
        return Err("no struct definition found".into());
    }
    let mut map = HashMap::new();
    for def in &defs {
        map.insert(def.name.clone(), def.clone());
    }
    Ok(build_object(&defs[0], &map, 0))
}

#[derive(Clone)]
struct StructDefinition {
    name: String,
    fields: Vec<StructField>,
}

#[derive(Clone)]
struct StructField {
    json_name: String,
    type_expr: String,
}

fn parse_go_structs(src: &str) -> Result<Vec<StructDefinition>, String> {
    let mut defs = Vec::new();
    let type_re = Regex::new(r"type\s+([A-Za-z_][A-Za-z0-9_]*)\s+struct\s*\{").unwrap();
    let bytes = src.as_bytes();
    let mut search_idx = 0;
    while let Some(cap) = type_re.captures(&src[search_idx..]) {
        let name = cap.get(1).unwrap().as_str().to_string();
        let brace_start = search_idx + cap.get(0).unwrap().end() - 1;
        let brace_end = find_matching_brace(bytes, brace_start)
            .ok_or_else(|| "unbalanced braces".to_string())?;
        let body = &src[brace_start + 1..brace_end];
        defs.push(StructDefinition {
            name,
            fields: parse_fields(body),
        });
        search_idx = brace_end + 1;
    }
    Ok(defs)
}

fn parse_fields(body: &str) -> Vec<StructField> {
    let mut fields = Vec::new();
    for raw_line in body.lines() {
        let line = raw_line.trim();
        if line.is_empty() || line.starts_with("//") {
            continue;
        }
        let mut content = line;
        if let Some(idx) = content.find("//") {
            content = content[..idx].trim();
        }
        if content.is_empty() {
            continue;
        }
        let mut tag = String::new();
        if let Some(start) = content.find('`') {
            if let Some(end) = content[start + 1..].find('`') {
                tag = content[start + 1..start + 1 + end].to_string();
                content = content[..start].trim();
            }
        }
        let parts: Vec<&str> = content.split_whitespace().collect();
        if parts.len() < 2 {
            continue;
        }
        let go_name = parts[0];
        let type_expr = parts[1..].join(" ");
        let json_name = parse_json_tag(&tag).unwrap_or_else(|| lower_first(go_name));
        fields.push(StructField {
            json_name,
            type_expr,
        });
    }
    fields
}

fn parse_json_tag(tag: &str) -> Option<String> {
    for part in tag.split_whitespace() {
        if let Some(rest) = part.strip_prefix("json:\"") {
            let end = rest.find('"').unwrap_or(rest.len());
            let value = &rest[..end];
            if value == "-" {
                return None;
            }
            return Some(value.split(',').next().unwrap_or(value).to_string());
        }
    }
    None
}

fn find_matching_brace(data: &[u8], open_idx: usize) -> Option<usize> {
    let mut depth = 0i32;
    for (idx, byte) in data.iter().enumerate().skip(open_idx) {
        match *byte {
            b'{' => depth += 1,
            b'}' => {
                depth -= 1;
                if depth == 0 {
                    return Some(idx);
                }
            }
            _ => {}
        }
    }
    None
}

fn build_object(
    def: &StructDefinition,
    defs: &HashMap<String, StructDefinition>,
    depth: usize,
) -> Value {
    if depth > 16 {
        return Value::Null;
    }
    let mut map = Map::new();
    for field in &def.fields {
        map.insert(
            field.json_name.clone(),
            sample_for_type(&field.type_expr, defs, depth + 1),
        );
    }
    Value::Object(map)
}

fn sample_for_type(expr: &str, defs: &HashMap<String, StructDefinition>, depth: usize) -> Value {
    if depth > 16 {
        return Value::Null;
    }
    let trimmed = expr.trim();
    if trimmed.starts_with("[]") {
        let inner = trimmed.trim_start_matches("[]");
        return Value::Array(vec![sample_for_type(inner, defs, depth + 1)]);
    }
    if trimmed.starts_with('*') {
        return sample_for_type(trimmed.trim_start_matches('*'), defs, depth);
    }
    if trimmed.starts_with("map[") {
        if let Some(end) = trimmed.find(']') {
            let value_type = trimmed[end + 1..].trim();
            let mut map = Map::new();
            map.insert("key".into(), sample_for_type(value_type, defs, depth + 1));
            return Value::Object(map);
        }
    }
    match trimmed {
        "string" | "[]byte" => Value::String(String::new()),
        "bool" => Value::Bool(false),
        "float32" | "float64" => Number::from_f64(0.0)
            .map(Value::Number)
            .unwrap_or(Value::Null),
        "int" | "int8" | "int16" | "int32" | "int64" | "uint" | "uint8" | "uint16" | "uint32"
        | "uint64" => Value::Number(Number::from(0)),
        other => defs
            .get(other)
            .map(|def| build_object(def, defs, depth + 1))
            .unwrap_or(Value::Null),
    }
}
