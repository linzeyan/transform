// Simple Protobuf <-> JSON mapper used to keep the converter deterministic.
use serde_json::{Map, Number, Value};
use std::collections::HashMap;

use crate::convert::helpers::{export_name, snake_name};
use crate::convert::json_utils::ordered_keys;

use crate::convert::json_utils::{encode_json, parse_json};

/// Renders Protobuf `message` definitions from a JSON object by mapping field types heuristically.
/// Nested objects become separate messages named after their field (e.g., `plugins` -> `message Plugins`).
///
/// # Example
/// ```
/// use wasm_core::convert::proto::json_to_proto;
/// let proto = json_to_proto(r#"{"id":1,"name":"Ada"}"#)?;
/// assert!(proto.contains("message AutoGenerated"));
/// # Ok::<(), String>(())
/// ```
pub fn json_to_proto(input: &str) -> Result<String, String> {
    let value = parse_json(input)?;
    let mut defs = Vec::new();
    let mut seen = HashMap::new();
    render_message("AutoGenerated", &value, &mut defs, &mut seen);
    Ok(defs.join("\n\n"))
}

/// Produces sample JSON from a Protobuf message definition (single message, no nested types).
pub fn proto_to_json(input: &str) -> Result<String, String> {
    let start = input.find('{').ok_or("invalid proto message")?;
    let end = input.rfind('}').ok_or("invalid proto message")?;
    let body = &input[start + 1..end];
    let mut map = Map::new();
    for line in body.lines() {
        let trimmed = line.trim().trim_end_matches(';');
        if trimmed.is_empty() {
            continue;
        }
        let repeated = trimmed.starts_with("repeated ");
        let tokens: Vec<&str> = trimmed.split_whitespace().collect();
        if tokens.len() < 2 {
            continue;
        }
        let (typ, name) = if repeated {
            (tokens[1], tokens[2])
        } else {
            (tokens[0], tokens[1])
        };
        let sample = sample_for_type(typ);
        let value = if repeated {
            Value::Array(vec![sample])
        } else {
            sample
        };
        map.insert(name.trim().into(), value);
    }
    if map.is_empty() {
        map.insert("value".into(), Value::String(String::new()));
    }
    encode_json(&Value::Object(map), false)
}

fn scalar_type(value: &Value) -> &'static str {
    match value {
        Value::Bool(_) => "bool",
        Value::Number(num) => {
            if num.is_i64() {
                "int32"
            } else {
                "double"
            }
        }
        Value::String(_) => "string",
        Value::Array(_) => "string",
        Value::Object(_) => "string",
        Value::Null => "string",
    }
}

fn render_message(
    name: &str,
    value: &Value,
    defs: &mut Vec<String>,
    seen: &mut HashMap<String, String>,
) {
    if seen.contains_key(name) {
        return;
    }
    let mut fields = Vec::new();
    match value {
        Value::Object(map) => {
            let mut index = 1;
            for key in ordered_keys(map) {
                if let Some(val) = map.get(&key) {
                    let field_name = snake_name(&key);
                    let (field_type, nested_defs) = proto_type_for_value(&key, val, seen);
                    if let Some((nested_name, nested_value)) = nested_defs {
                        render_message(&nested_name, nested_value, defs, seen);
                    }
                    fields.push(format!("  {} {} = {};", field_type, field_name, index));
                    index += 1;
                }
            }
        }
        _ => fields.push("  string value = 1;".into()),
    }
    seen.insert(name.to_string(), String::new());
    defs.push(format!("message {} {{\n{}\n}}", name, fields.join("\n")));
}

fn proto_type_for_value<'a>(
    key: &str,
    value: &'a Value,
    seen: &HashMap<String, String>,
) -> (String, Option<(String, &'a Value)>) {
    match value {
        Value::Object(_) => {
            let base = export_name(key);
            let nested = unique_name(&base, seen);
            (nested.clone(), Some((nested, value)))
        }
        Value::Array(items) => {
            if let Some(first_obj) = items.iter().find(|v| v.is_object()) {
                let base = format!("{}Item", export_name(key));
                let nested = unique_name(&base, seen);
                (
                    format!("repeated {}", nested.clone()),
                    Some((nested, first_obj)),
                )
            } else {
                (format!("repeated {}", scalar_type(&array_rep(items))), None)
            }
        }
        _ => (scalar_type(value).into(), None),
    }
}

fn array_rep(items: &[Value]) -> Value {
    for item in items {
        if item.is_null() {
            continue;
        }
        return item.clone();
    }
    Value::Null
}

fn unique_name(base: &str, seen: &HashMap<String, String>) -> String {
    if !seen.contains_key(base) {
        return base.to_string();
    }
    let mut idx = 2;
    loop {
        let candidate = format!("{}{}", base, idx);
        if !seen.contains_key(&candidate) {
            return candidate;
        }
        idx += 1;
    }
}

fn sample_for_type(typ: &str) -> Value {
    match typ {
        "bool" => Value::Bool(false),
        "int32" | "uint32" | "sint32" | "fixed32" => Value::Number(Number::from(0)),
        "int64" | "uint64" | "sint64" | "fixed64" => Value::Number(Number::from(0)),
        "double" | "float" => Number::from_f64(0.0)
            .map(Value::Number)
            .unwrap_or_else(|| Value::Number(Number::from(0))),
        _ => Value::String(String::new()),
    }
}
