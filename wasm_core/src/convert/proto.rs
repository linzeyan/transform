use serde_json::{Map, Number, Value};

use crate::convert::json_utils::{encode_json, parse_json};

pub fn json_to_proto(input: &str) -> Result<String, String> {
    let value = parse_json(input)?;
    let mut fields = Vec::new();
    match value {
        Value::Object(map) => {
            let mut index = 1;
            for (key, val) in map {
                let field_type = scalar_type(&val);
                fields.push(format!("  {} {} = {};", field_type, key, index));
                index += 1;
            }
        }
        _ => fields.push("  string value = 1;".into()),
    }
    Ok(format!(
        "message AutoGenerated {{\n{}\n}}",
        fields.join("\n")
    ))
}

pub fn proto_to_json(input: &str) -> Result<String, String> {
    let start = input.find('{').ok_or("invalid proto message")?;
    let end = input.rfind('}').ok_or("invalid proto message")?;
    let body = &input[start + 1..end];
    let mut map = Map::new();
    for line in body.lines() {
        let trimmed = line.trim().trim_end_matches(';');
        if trimmed.is_empty() {
            continue;
        }
        let repeated = trimmed.starts_with("repeated ");
        let tokens: Vec<&str> = trimmed.split_whitespace().collect();
        if tokens.len() < 2 {
            continue;
        }
        let (typ, name) = if repeated {
            (tokens[1], tokens[2])
        } else {
            (tokens[0], tokens[1])
        };
        let sample = sample_for_type(typ);
        let value = if repeated {
            Value::Array(vec![sample])
        } else {
            sample
        };
        map.insert(name.trim().into(), value);
    }
    if map.is_empty() {
        map.insert("value".into(), Value::String(String::new()));
    }
    encode_json(&Value::Object(map), false)
}

fn scalar_type(value: &Value) -> &'static str {
    match value {
        Value::Bool(_) => "bool",
        Value::Number(num) => {
            if num.is_i64() {
                "int32"
            } else {
                "double"
            }
        }
        Value::String(_) => "string",
        Value::Array(_) => "string",
        Value::Object(_) => "string",
        Value::Null => "string",
    }
}

fn sample_for_type(typ: &str) -> Value {
    match typ {
        "bool" => Value::Bool(false),
        "int32" | "uint32" | "sint32" | "fixed32" => Value::Number(Number::from(0)),
        "int64" | "uint64" | "sint64" | "fixed64" => Value::Number(Number::from(0)),
        "double" | "float" => Number::from_f64(0.0)
            .map(Value::Number)
            .unwrap_or_else(|| Value::Number(Number::from(0))),
        _ => Value::String(String::new()),
    }
}
