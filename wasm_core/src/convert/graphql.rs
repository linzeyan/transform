// Minimal GraphQL schema synthesizer and sampler for the converter workspace.
use serde_json::{Map, Number, Value};

use crate::convert::json_utils::{encode_json, parse_json};

const ROOT_NAME: &str = "AutoGenerated";

pub fn json_to_graphql(input: &str) -> Result<String, String> {
    let value = parse_json(input)?;
    let mut body = Vec::new();
    match value {
        Value::Object(map) => {
            for (key, val) in map {
                let field_type = scalar_type(&val);
                body.push(format!("  {}: {}", key, field_type));
            }
        }
        _ => {
            body.push("  value: String".into());
        }
    }
    if body.is_empty() {
        body.push("  value: String".into());
    }
    Ok(format!("type {} {{\n{}\n}}", ROOT_NAME, body.join("\n")))
}

pub fn graphql_to_json(input: &str) -> Result<String, String> {
    let start = input.find('{').ok_or("invalid GraphQL schema")?;
    let end = input.rfind('}').ok_or("invalid GraphQL schema")?;
    let body = &input[start + 1..end];
    let mut map = Map::new();
    for line in body.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() {
            continue;
        }
        if let Some((name, typ)) = trimmed.split_once(':') {
            map.insert(name.trim().into(), sample_for_type(typ.trim()));
        }
    }
    if map.is_empty() {
        map.insert("value".into(), Value::String(String::new()));
    }
    encode_json(&Value::Object(map), false)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn json_to_graphql_produces_type() {
        let gql = json_to_graphql(r#"{"id":1,"name":"Ada"}"#).unwrap();
        assert!(gql.contains("type AutoGenerated"));
        assert!(gql.contains("name: String"));
    }

    #[test]
    fn graphql_back_to_json() {
        let schema = "type AutoGenerated {\n  id: Int\n  name: String\n}";
        let json = graphql_to_json(schema).unwrap();
        let v: Value = serde_json::from_str(&json).unwrap();
        assert!(v.get("name").is_some());
    }
}

fn scalar_type(value: &Value) -> &'static str {
    match value {
        Value::Bool(_) => "Boolean",
        Value::Number(num) => {
            if num.is_i64() {
                "Int"
            } else {
                "Float"
            }
        }
        Value::String(_) => "String",
        Value::Array(_) => "[String]",
        Value::Object(_) => "String",
        Value::Null => "String",
    }
}

fn sample_for_type(typ: &str) -> Value {
    match typ.trim_matches(&['[', ']', '!'][..]) {
        "Boolean" => Value::Bool(false),
        "Int" => Value::Number(Number::from(0)),
        "Float" => Number::from_f64(0.0)
            .map(Value::Number)
            .unwrap_or_else(|| Value::Number(Number::from(0))),
        _ => Value::String(String::new()),
    }
}
