// Minimal GraphQL schema synthesizer and sampler for the converter workspace.
use serde_json::{Map, Number, Value};
use std::collections::HashMap;

use crate::convert::helpers::export_name;
use crate::convert::json_utils::{encode_json, ordered_keys, parse_json};

const ROOT_NAME: &str = "AutoGenerated";

/// Renders GraphQL `type` definitions from JSON input.
///
/// Nested objects become named types based on the field name, and arrays of objects become
/// lists of that nested type. Unknown or mixed shapes fall back to `String` fields so the
/// output stays valid.
///
/// # Example
/// ```
/// use wasm_core::convert::graphql::json_to_graphql;
/// let schema = json_to_graphql(r#"{"id":1,"name":"Ada"}"#)?;
/// assert!(schema.contains("type AutoGenerated"));
/// # Ok::<(), String>(())
/// ```
pub fn json_to_graphql(input: &str) -> Result<String, String> {
    let value = parse_json(input)?;
    let mut defs = Vec::new();
    let mut seen = HashMap::new();
    render_type(ROOT_NAME, &value, &mut defs, &mut seen);
    Ok(defs.join("\n\n"))
}

/// Produces sample JSON from a GraphQL schema string by mapping common scalar
/// names (Int/Float/Boolean/String) into JSON values.
///
/// # Example
/// ```
/// use wasm_core::convert::graphql::graphql_to_json;
/// let json = graphql_to_json("type AutoGenerated { id: Int, name: String }")?;
/// assert!(json.contains(\"\\\"name\\\"\"));
/// # Ok::<(), String>(())
/// ```
pub fn graphql_to_json(input: &str) -> Result<String, String> {
    let start = input.find('{').ok_or("invalid GraphQL schema")?;
    let end = input.rfind('}').ok_or("invalid GraphQL schema")?;
    let body = &input[start + 1..end];
    let mut map = Map::new();
    for line in body.lines() {
        let trimmed = line.trim();
        if trimmed.is_empty() {
            continue;
        }
        if let Some((name, typ)) = trimmed.split_once(':') {
            map.insert(name.trim().into(), sample_for_type(typ.trim()));
        }
    }
    if map.is_empty() {
        map.insert("value".into(), Value::String(String::new()));
    }
    encode_json(&Value::Object(map), false)
}

fn scalar_type(value: &Value) -> &'static str {
    match value {
        Value::Bool(_) => "Boolean",
        Value::Number(num) => {
            if num.is_i64() {
                "Int"
            } else {
                "Float"
            }
        }
        Value::String(_) => "String",
        Value::Array(_) => "[String]",
        Value::Object(_) => "String",
        Value::Null => "String",
    }
}

fn render_type(
    name: &str,
    value: &Value,
    defs: &mut Vec<String>,
    seen: &mut HashMap<String, String>,
) {
    if seen.contains_key(name) {
        return;
    }
    let mut fields = Vec::new();
    match value {
        Value::Object(map) => {
            for key in ordered_keys(map) {
                if let Some(val) = map.get(&key) {
                    let field_name = graphql_field_name(&key);
                    let (typ, nested) = graphql_type_for_value(&key, val, seen);
                    if let Some((nested_name, nested_val)) = nested {
                        render_type(&nested_name, nested_val, defs, seen);
                    }
                    fields.push(format!("  {}: {}", field_name, typ));
                }
            }
        }
        _ => fields.push("  value: String".into()),
    }
    if fields.is_empty() {
        fields.push("  value: String".into());
    }
    seen.insert(name.to_string(), String::new());
    defs.push(format!("type {} {{\n{}\n}}", name, fields.join("\n")));
}

fn graphql_type_for_value<'a>(
    key: &str,
    value: &'a Value,
    seen: &HashMap<String, String>,
) -> (String, Option<(String, &'a Value)>) {
    match value {
        Value::Object(_) => {
            let base = export_name(key);
            let nested = unique_name(&base, seen);
            (nested.clone(), Some((nested, value)))
        }
        Value::Array(items) => {
            if let Some(first_obj) = items.iter().find(|v| v.is_object()) {
                let base = format!("{}Item", export_name(key));
                let nested = unique_name(&base, seen);
                (format!("[{}]", nested.clone()), Some((nested, first_obj)))
            } else {
                (format!("[{}]", scalar_type(&array_rep(items))), None)
            }
        }
        _ => (scalar_type(value).into(), None),
    }
}

fn graphql_field_name(key: &str) -> String {
    let pascal = export_name(key);
    let mut chars = pascal.chars().collect::<Vec<char>>();
    if chars.is_empty() {
        return "field".into();
    }
    if let Some(first) = chars.get_mut(0) {
        *first = first.to_ascii_lowercase();
    }
    let candidate: String = chars.into_iter().collect();
    if candidate
        .chars()
        .next()
        .map(|c| c.is_ascii_alphabetic())
        .unwrap_or(false)
    {
        candidate
    } else {
        format!("field{}", candidate)
    }
}

fn array_rep(items: &[Value]) -> Value {
    for item in items {
        if item.is_null() {
            continue;
        }
        return item.clone();
    }
    Value::String(String::new())
}

fn unique_name(base: &str, seen: &HashMap<String, String>) -> String {
    if !seen.contains_key(base) {
        return base.to_string();
    }
    let mut idx = 2;
    loop {
        let candidate = format!("{}{}", base, idx);
        if !seen.contains_key(&candidate) {
            return candidate;
        }
        idx += 1;
    }
}

fn sample_for_type(typ: &str) -> Value {
    match typ.trim_matches(&['[', ']', '!'][..]) {
        "Boolean" => Value::Bool(false),
        "Int" => Value::Number(Number::from(0)),
        "Float" => Number::from_f64(0.0)
            .map(Value::Number)
            .unwrap_or_else(|| Value::Number(Number::from(0))),
        _ => Value::String(String::new()),
    }
}
