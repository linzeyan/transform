use crate::convert::{
    formats, go_struct, graphql, helpers, json_utils, markdown, msgpack, proto, schema, toon, xml,
};
use serde_json::{Value, json};

#[test]
fn formats_json_to_yaml_and_back() {
    let yaml = formats::convert_formats("JSON", "YAML", "{\"a\":1}").unwrap();
    let back = formats::convert_formats("YAML", "JSON", &yaml).unwrap();
    let v: Value = serde_json::from_str(&back).unwrap();
    assert_eq!(v["a"], 1);
}

#[test]
fn formats_go_struct_generation() {
    let go = formats::convert_formats("JSON", "Go Struct", "{\"id\":1}").unwrap();
    assert!(go.contains("struct"));
}

#[test]
fn formats_format_content_minifies() {
    let min = formats::format_content("JSON", "{\n  \"a\": 1\n}\n", true).unwrap();
    assert_eq!(min, "{\"a\":1}");
}

#[test]
fn go_struct_json_to_go_struct_generates_fields() {
    let json: Value = serde_json::from_str(r#"{"id":1,"name":"Ada"}"#).unwrap();
    let go = go_struct::json_value_to_go(&json);
    assert!(go.contains("type AutoGenerated"));
    assert!(go.contains("Id"));
    assert!(go.contains("Name"));
}

#[test]
fn go_struct_to_value_parses_struct() {
    let value = go_struct::go_struct_to_value("type User struct { Id int `json:\"id\"` }").unwrap();
    assert_eq!(value.get("id").unwrap(), 0);
}

#[test]
fn graphql_json_to_graphql_produces_type() {
    let gql = graphql::json_to_graphql(r#"{"id":1,"name":"Ada"}"#).unwrap();
    assert!(gql.contains("type AutoGenerated"));
    assert!(gql.contains("name: String"));
}

#[test]
fn graphql_back_to_json() {
    let schema = "type AutoGenerated {\n  id: Int\n  name: String\n}";
    let json = graphql::graphql_to_json(schema).unwrap();
    let v: Value = serde_json::from_str(&json).unwrap();
    assert!(v.get("name").is_some());
}

#[test]
fn helpers_export_and_lower_first() {
    assert_eq!(helpers::export_name("123foo_bar"), "foo_Bar");
    assert_eq!(helpers::lower_first("UserName"), "userName");
    assert!(helpers::is_all_upper("ABC"));
    assert_eq!(
        helpers::split_words("HTTPStatus200"),
        vec!["HTTP", "Status", "200"]
    );
}

#[test]
fn json_utils_basic_conversions() {
    let num_int: serde_json::Number = serde_json::from_str("42").unwrap();
    let num_float: serde_json::Number = serde_json::from_str("42.1").unwrap();
    assert!(json_utils::looks_integer(&num_int));
    assert!(!json_utils::looks_integer(&num_float));

    let mut map = serde_json::Map::new();
    map.insert("b".into(), Value::Null);
    map.insert("a".into(), Value::Null);
    assert_eq!(json_utils::ordered_keys(&map), vec!["a", "b"]);

    let yaml_value: serde_yaml::Value = serde_yaml::from_str("name: Ada").unwrap();
    let json_value = json_utils::yaml_to_json(yaml_value);
    assert_eq!(json_value["name"], "Ada");

    let toml_val = json_utils::json_to_toml(&json!({"name":"Ada"})).unwrap();
    assert!(toml_val.to_string().contains("name = \"Ada\""));
}

#[test]
fn markdown_converts_markdown_and_html() {
    let html = markdown::markdown_to_html("- item").unwrap();
    assert!(html.contains("<ul>"));
    let md = markdown::html_to_markdown("<h1>Title</h1>").unwrap();
    assert!(md.to_lowercase().contains("# title"));
}

#[test]
fn msgpack_round_trip() {
    let encoded = msgpack::json_to_msgpack(r#"{"hello":"world"}"#).unwrap();
    let back = msgpack::msgpack_to_json(&encoded).unwrap();
    let v: Value = serde_json::from_str(&back).unwrap();
    assert_eq!(v["hello"], "world");
}

#[test]
fn proto_json_to_proto_and_back() {
    let proto_text = proto::json_to_proto(r#"{"id":1,"name":"Ada"}"#).unwrap();
    assert!(proto_text.contains("message AutoGenerated"));
    let json =
        proto::proto_to_json("message AutoGenerated {\n  string name = 1;\n  int32 id = 2;\n}")
            .unwrap();
    let v: Value = serde_json::from_str(&json).unwrap();
    assert!(v.get("name").is_some());
}

#[test]
fn schema_builds_schema_and_sample() {
    let src = json!({"name": "Ada", "age": 30});
    let schema_val = schema::json_to_schema(&src);
    assert_eq!(schema_val["type"], "object");
    let sample = schema::schema_to_sample(&schema_val);
    assert!(sample.get("name").is_some());
}

#[test]
fn schema_builds_array_schema() {
    let src = json!([1, 2, 3]);
    let schema_val = schema::json_to_schema(&src);
    assert_eq!(schema_val["type"], "array");
}

#[test]
fn toon_round_trip_between_json_and_toon() {
    let payload = json!({
        "users": [
            {"id": 1, "name": "Ada"},
            {"id": 2, "name": "Bob"}
        ]
    });
    let json_text = serde_json::to_string(&payload).unwrap();
    let toon_text = toon::json_to_toon(&json_text).expect("encode TOON");
    assert!(toon_text.contains("users"));
    let json_back = toon::toon_to_json(&toon_text).expect("decode TOON");
    let parsed: Value = serde_json::from_str(&json_back).unwrap();
    assert_eq!(parsed, payload);
}

#[test]
fn toon_invalid_json_payload_is_rejected() {
    assert!(toon::json_to_toon("not valid json").is_err());
}

#[test]
fn xml_json_to_xml_wraps_root() {
    let xml_text = xml::json_to_xml(r#"{"name":"Ada"}"#).unwrap();
    assert!(xml_text.contains("<root>"));
    assert!(xml_text.contains("<name>Ada</name>"));
}

#[test]
fn xml_to_json_round_trip_single_field() {
    let json = xml::xml_to_json("<root><name>Ada</name></root>").unwrap();
    let v: Value = serde_json::from_str(&json).unwrap();
    assert_eq!(v["name"], "Ada");
}
