import initWasm, {
  generate_uuids,
  generate_user_agents,
  convert_number_base,
  convert_units,
  ipv4_info,
  url_encode,
  url_decode,
  jwt_encode,
  jwt_decode,
  encode_content,
  decode_content,
  hash_content,
  transform_format,
  format_content_text,
  markdown_to_html_text,
  html_to_markdown_text,
  random_number_string,
} from "./pkg/wasm_core.js";

const formats = [
  "JSON",
  "Go Struct",
  "YAML",
  "TOML",
  "XML",
  "JSON Schema",
  "GraphQL Schema",
  "Protobuf",
  "TOON",
  "MsgPack",
];

const samples = {
  JSON: '{\n  "name": "Ricky",\n  "age": 27\n}',
  XML: `<root>\n  <name>Ricky</name>\n  <age>27</age>\n</root>`,
  "Go Struct":
    'type AutoGenerated struct {\n  UserID string `json:"user_id"`\n}\n',
  YAML: "name: Ricky\nage: 27",
  TOML: 'name = "Ricky"\nage = 27',
  "JSON Schema": `{
  "type": "object",
  "properties": {
    "name": { "type": "string" },
    "age": { "type": "number" }
  },
  "required": ["name"]
}`,
  "GraphQL Schema": `type AutoGenerated {
  userID: String!
}`,
  Protobuf: `message AutoGenerated {
  string user_id = 1;
}`,
  TOON: `users[2]{id,name}:
  1,Alice
  2,Bob`,
  MsgPack: "Paste base64 MsgPack here...",
};

const supportedFormats = new Set(formats);

const unitKeys = [
  "bit",
  "byte",
  "kilobit",
  "kilobyte",
  "megabit",
  "megabyte",
  "gigabit",
  "gigabyte",
  "terabit",
  "terabyte",
];

const digitChoices = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];

const coderTools = [
  {
    id: "coder-encode",
    mode: "encode",
    label: "Base Encoders",
    description: "Base32/64/85/91 encodings.",
  },
  {
    id: "coder-decode",
    mode: "decode",
    label: "Base Decoders",
    description: "Decode BaseX back to plain text.",
  },
  {
    id: "coder-hash",
    mode: "hash",
    label: "Hash",
    description: "Hashes from Go's stdlib.",
  },
  {
    id: "coder-url",
    pair: "url",
    label: "URL Encode/Decode",
    description: "Bidirectional URL percent-encoding helper.",
  },
  {
    id: "coder-jwt",
    pair: "jwt",
    label: "JWT Encode/Decode",
    description: "Sign JSON payloads and inspect JWT tokens.",
  },
];

const coderToolModes = {
  "coder-encode": "encode",
  "coder-decode": "decode",
  "coder-hash": "hash",
};

const encodingGroups = [
  {
    id: "base16",
    label: "Base16",
    variants: [{ key: "hex_upper", label: "Hex" }],
  },
  {
    id: "base32",
    label: "Base32",
    variants: [
      { key: "base32_standard", label: "Standard" },
      { key: "base32_standard_no_padding", label: "Standard · No padding" },
      { key: "base32_hex", label: "Hex" },
      { key: "base32_hex_no_padding", label: "Hex · No padding" },
    ],
  },
  {
    id: "base64",
    label: "Base64",
    variants: [
      { key: "base64_standard", label: "Standard" },
      { key: "base64_raw_standard", label: "Standard · Raw" },
      { key: "base64_url", label: "URL-safe" },
      { key: "base64_raw_url", label: "URL-safe · Raw" },
    ],
  },
  {
    id: "base85",
    label: "Base85",
    variants: [{ key: "base85_ascii85", label: "ASCII85" }],
  },
  {
    id: "base91",
    label: "Base91",
    variants: [{ key: "base91", label: "Standard" }],
  },
];

const encodingVariantMap = new Map();
const allEncodingVariants = [];
encodingGroups.forEach((group) => {
  group.variants.forEach((variant) => {
    encodingVariantMap.set(variant.key, {
      group: group.label,
      label: variant.label,
    });
    allEncodingVariants.push({ ...variant, group: group.label });
  });
});

const hashGroups = [
  { label: "Message Digest", keys: ["md5", "sha1"] },
  {
    label: "SHA-2",
    keys: ["sha224", "sha256", "sha384", "sha512", "sha512_224", "sha512_256"],
  },
  {
    label: "Checksums",
    keys: ["crc32_ieee", "crc32_castagnoli", "crc64_iso", "crc64_ecma", "adler32"],
  },
  {
    label: "FNV",
    keys: ["fnv32", "fnv32a", "fnv64", "fnv64a", "fnv128", "fnv128a"],
  },
];

const hashLabels = {
  md5: "MD5",
  sha1: "SHA-1",
  sha224: "SHA-224",
  sha256: "SHA-256",
  sha384: "SHA-384",
  sha512: "SHA-512",
  sha512_224: "SHA-512/224",
  sha512_256: "SHA-512/256",
  crc32_ieee: "CRC32 (IEEE)",
  crc32_castagnoli: "CRC32 (Castagnoli)",
  crc64_iso: "CRC64 (ISO)",
  crc64_ecma: "CRC64 (ECMA)",
  adler32: "Adler32",
  fnv32: "FNV-1 32",
  fnv32a: "FNV-1a 32",
  fnv64: "FNV-1 64",
  fnv64a: "FNV-1a 64",
  fnv128: "FNV-1 128",
  fnv128a: "FNV-1a 128",
};

const coderModeDescriptions = {
  encode: "Encode text into multiple bases.",
  decode: "Decode text with your selected base.",
  hash: "Generate hashes provided by Go's standard library.",
};

const coderModeTitles = {
  encode: "Encode",
  decode: "Decode",
  hash: "Hash",
};

const coderResultHints = {
  encode: "Base32 / Base64 / Base85 / Base91 / Hex",
  decode: "Decoded output",
  hash: "MD5 / SHA / CRC / FNV",
};

const coderPlaceholders = {
  encode: "Type or paste text...",
  decode: "Paste Base32/64/85/91 text to decode...",
  hash: "Enter text to compute hashes",
};

const pairToolConfigs = {
  "coder-url": {
    type: "url",
    inputLabel: "URL Encode",
    inputHint: "Enter original text to URL-encode.",
    inputPlaceholder: "https://example.com/search?q=Taipei 101",
    outputLabel: "URL Decode",
    outputHint: "Paste encoded text to decode automatically.",
    outputPlaceholder: "https%3A%2F%2Fexample.com%2Fsearch%3Fq%3DTaipei101",
  },
  "coder-jwt": {
    type: "jwt",
    inputLabel: "JWT Payload (JSON)",
    inputHint: "Enter payload JSON; token is generated using the selected algorithm.",
    inputPlaceholder: '{\n  "sub": "1234567890",\n  "name": "John Doe"\n}',
    outputLabel: "JWT Token",
    outputHint: "Paste a JWT token to decode.",
    outputPlaceholder: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9....",
  },
  "converter-html-md": {
    type: "markdown",
    inputLabel: "Markdown → HTML",
    inputHint: "Enter Markdown to render HTML on the right.",
    inputPlaceholder: "# Title\n\n- item 1\n- item 2",
    outputLabel: "HTML → Markdown",
    outputHint: "Paste HTML to convert back to Markdown.",
    outputPlaceholder: "<h1>Title</h1>",
  },
};

const toolGroups = [
  {
    name: "Converter",
    tools: [
      {
        id: "format",
        label: "Format Converter",
        description: "Convert between structured data formats.",
      },
      {
        id: "converter-html-md",
        label: "HTML ↔ Markdown",
        description: "Convert between Markdown and HTML.",
      },
      {
        id: "converter-number-bases",
        label: "Number Bases",
        description: "Binary / Octal / Decimal / Hex conversions.",
      },
      {
        id: "converter-units",
        label: "Unit Converter",
        description: "Bits, Bytes, and SI multiples.",
      },
      {
        id: "converter-ipv4",
        label: "IP Tools",
        description: "IPv4/IPv6 helpers for CIDR, ranges, and formats.",
      },
    ],
  },
  {
    name: "Coder",
    tools: coderTools.map((tool) => ({
      id: tool.id,
      label: tool.label,
      description: tool.description,
    })),
  },
  {
    name: "Generator",
    tools: [
      {
        id: "generator-uuid",
        label: "UUID",
        description: "Generate UUID v1-v8, GUID, and ULID.",
      },
      {
        id: "generator-useragent",
        label: "User-Agent",
        description: "Generate realistic browser user agents.",
      },
      {
        id: "generator-random",
        label: "Random Number",
        description: "Random numeric strings with custom digits.",
      },
    ],
  },
];

const workspaceByTool = {
  format: "converterWorkspace",
  "converter-html-md": "pairWorkspace",
  "converter-number-bases": "numberWorkspace",
  "converter-units": "unitWorkspace",
  "converter-ipv4": "ipv4Workspace",
  "coder-encode": "coderWorkspace",
  "coder-decode": "coderWorkspace",
  "coder-hash": "coderWorkspace",
  "coder-url": "pairWorkspace",
  "coder-jwt": "pairWorkspace",
  "generator-uuid": "uuidWorkspace",
  "generator-useragent": "userAgentWorkspace",
  "generator-random": "randomWorkspace",
};

const coderMainTools = new Set(["coder-encode", "coder-decode", "coder-hash"]);
const pairTools = new Set(["converter-html-md", "coder-url", "coder-jwt"]);
const numberTools = new Set(["converter-number-bases"]);
const unitTools = new Set(["converter-units"]);
const ipv4Tools = new Set(["converter-ipv4"]);
const generatorTools = new Set([
  "generator-uuid",
  "generator-useragent",
  "generator-random",
]);
const uuidToolSet = new Set(["generator-uuid"]);
const userAgentToolSet = new Set(["generator-useragent"]);
const randomToolSet = new Set(["generator-random"]);
const implementedTools = new Set([
  "format",
  "converter-html-md",
  "generator-uuid",
  "generator-useragent",
  "converter-number-bases",
  "converter-units",
  "converter-ipv4",
  "coder-encode",
  "coder-decode",
  "coder-hash",
  "coder-url",
  "coder-jwt",
  "generator-random",
]);

const toolInfo = {};
toolGroups.forEach((group) => {
  group.tools.forEach((tool) => {
    toolInfo[tool.id] = {
      ...tool,
      workspace: workspaceByTool[tool.id] || "converterWorkspace",
    };
  });
});

const elements = {};
const workspaceIds = [
  "converterWorkspace",
  "coderWorkspace",
  "pairWorkspace",
  "numberWorkspace",
  "unitWorkspace",
  "ipv4Workspace",
  "uuidWorkspace",
  "userAgentWorkspace",
  "randomWorkspace",
];

const defaultDecoder = allEncodingVariants[0]?.key || "";

const state = {
  currentTool: "format",
  wasmReady: false,
  uuidUppercase: false,
  currentUUIDs: {},
  currentBrowserFilter: "",
  currentOSFilter: "",
  currentUserAgents: [],
  coderMode: "encode",
  selectedDecoder: defaultDecoder,
  hashUppercase: false,
  lastEncodeResults: null,
  lastHashResults: null,
  encodeCaseMap: { base16: true, base32: true },
  currentPairTool: null,
  pairSyncing: false,
  pairLastSource: "input",
  numberSyncing: false,
  unitSyncing: false,
  randomDigits: new Set(digitChoices),
  randomAllowLeadingZero: true,
  randomLength: 12,
  randomResult: "",
  formatKey: null,
};

let coderTimer = null;
let convertTimer = null;

const uuidDisplayOrder = [
  "v1",
  "v2",
  "v3",
  "v4",
  "v5",
  "v6",
  "v7",
  "v8",
  "guid",
  "ulid",
];
const uuidDisplayLabels = {
  guid: "GUID",
  ulid: "ULID",
};

boot();

async function boot() {
  cacheElements();
  initCoderControls();
  renderSidebar();
  bindUI();
  renderCoderEmpty();
  updateCoderTexts();
  selectTool(state.currentTool);
  setStatus("Loading WebAssembly...", false);
  try {
    await initWasm();
    state.wasmReady = true;
    setStatus("Ready", false);
    if (isUUIDTool(state.currentTool)) {
      refreshUUIDs(true);
    }
    if (isUserAgentTool(state.currentTool)) {
      refreshUserAgents(true);
    }
    if (
      isPairTool(state.currentTool) &&
      ((elements.pairInput && elements.pairInput.value.trim()) ||
        (elements.pairOutput && elements.pairOutput.value.trim()))
    ) {
      runPairConversion(state.pairLastSource);
    }
    if (isNumberTool(state.currentTool)) {
      const hasNumberValue = [
        elements.numberBinary,
        elements.numberOctal,
        elements.numberDecimal,
        elements.numberHex,
      ].some((input) => input && input.value.trim());
      if (hasNumberValue) {
        runNumberConversion("decimal");
      }
    }
    if (isIPv4Tool(state.currentTool) && elements.ipv4Input?.value.trim()) {
      runIPv4Conversion();
    }
  } catch (err) {
    console.error(err);
    setStatus(`Failed to load WebAssembly: ${err.message}`, true);
  }
}

function cacheElements() {
  elements.toolGroups = document.getElementById("toolGroups");
  elements.toolName = document.getElementById("toolName");
  elements.toolDesc = document.getElementById("toolDesc");
  elements.converterControls = document.getElementById("converterControls");
  elements.from = document.getElementById("fromSelect");
  elements.to = document.getElementById("toSelect");
  elements.swap = document.getElementById("swap");
  elements.input = document.getElementById("input");
  elements.output = document.getElementById("output");
  elements.copy = document.getElementById("copy");
  elements.clear = document.getElementById("clear");
  elements.formatInput = document.getElementById("formatInput");
  elements.minifyInput = document.getElementById("minifyInput");
  elements.formatOutput = document.getElementById("formatOutput");
  elements.minifyOutput = document.getElementById("minifyOutput");
  elements.status = document.getElementById("status");
  elements.coderWorkspace = document.getElementById("coderWorkspace");
  elements.coderInput = document.getElementById("coderInput");
  elements.coderResults = document.getElementById("coderResults");
  elements.coderWorkspaceTitle = document.getElementById("coderWorkspaceTitle");
  elements.coderModeHint = document.getElementById("coderModeHint");
  elements.decodeVariantWrap = document.getElementById("decodeVariantWrap");
  elements.decodeVariant = document.getElementById("decodeVariant");
  elements.coderResultActions = document.getElementById("coderResultActions");
  elements.hashToggleCase = document.getElementById("hashToggleCase");
  elements.coderResultHeading = document.getElementById("coderResultHeading");
  elements.coderResultHint = document.getElementById("coderResultHint");
  elements.pairWorkspace = document.getElementById("pairWorkspace");
  elements.pairInput = document.getElementById("pairInput");
  elements.pairOutput = document.getElementById("pairOutput");
  elements.pairInputLabel = document.getElementById("pairInputLabel");
  elements.pairOutputLabel = document.getElementById("pairOutputLabel");
  elements.pairInputHint = document.getElementById("pairInputHint");
  elements.pairOutputHint = document.getElementById("pairOutputHint");
  elements.jwtControls = document.getElementById("jwtControls");
  elements.jwtAlgorithm = document.getElementById("jwtAlgorithm");
  elements.jwtSecret = document.getElementById("jwtSecret");
  elements.pairOutputMeta = document.getElementById("pairOutputMeta");
  elements.numberWorkspace = document.getElementById("numberWorkspace");
  elements.numberBinary = document.getElementById("numberBinary");
  elements.numberOctal = document.getElementById("numberOctal");
  elements.numberDecimal = document.getElementById("numberDecimal");
  elements.numberHex = document.getElementById("numberHex");
  elements.unitWorkspace = document.getElementById("unitWorkspace");
  unitKeys.forEach((key) => {
    const id = `unit${capitalize(key)}`;
    elements[id] = document.getElementById(id);
  });
  elements.ipv4Workspace = document.getElementById("ipv4Workspace");
  elements.ipv4Input = document.getElementById("ipv4Input");
  elements.ipv4Results = document.getElementById("ipv4Results");
  elements.uuidList = document.getElementById("uuidList");
  elements.uuidToggleCase = document.getElementById("uuidToggleCase");
  elements.uuidRegenerate = document.getElementById("uuidRegenerate");
  elements.uaBrowser = document.getElementById("uaBrowser");
  elements.uaOS = document.getElementById("uaOS");
  elements.uaResults = document.getElementById("uaResults");
  elements.randomWorkspace = document.getElementById("randomWorkspace");
  elements.randomLength = document.getElementById("randomLength");
  elements.randomAllowZero = document.getElementById("randomAllowZero");
  elements.randomDigitToggles = document.getElementById("randomDigitToggles");
  elements.randomGenerate = document.getElementById("randomGenerate");
  elements.randomResult = document.getElementById("randomResult");
}

function renderSidebar() {
  if (!elements.toolGroups) return;
  elements.toolGroups.innerHTML = "";
  toolGroups.forEach((group) => {
    const details = document.createElement("details");
    details.open = true;
    const summary = document.createElement("summary");
    summary.textContent = group.name;
    details.appendChild(summary);
    const wrapper = document.createElement("div");
    wrapper.className = "tool-buttons";
    group.tools.forEach((tool) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.dataset.toolId = tool.id;
      btn.textContent = tool.label;
      btn.addEventListener("click", () => selectTool(tool.id));
      wrapper.appendChild(btn);
    });
    details.appendChild(wrapper);
    elements.toolGroups.appendChild(details);
  });
  updateToolButtons();
}

function initCoderControls() {
  if (!elements.decodeVariant) return;
  const options = allEncodingVariants
    .map(
      (variant) =>
        `<option value="${variant.key}">${variant.group} · ${variant.label}</option>`,
    )
    .join("");
  elements.decodeVariant.innerHTML = options;
  if (!state.selectedDecoder && allEncodingVariants.length > 0) {
    state.selectedDecoder = allEncodingVariants[0].key;
  }
  if (state.selectedDecoder) {
    elements.decodeVariant.value = state.selectedDecoder;
  }
}

function bindUI() {
  elements.swap?.addEventListener("click", () => {
    if (state.currentTool !== "format") return;
    const from = elements.from?.value || "";
    const to = elements.to?.value || "";
    if (elements.from) elements.from.value = to;
    if (elements.to) elements.to.value = from;
    if (elements.input && elements.output) {
      const previous = elements.input.value;
      elements.input.value = elements.output.value;
      elements.output.value = previous;
    }
    ensureConverterMode();
    scheduleConvert(true);
  });
  elements.copy?.addEventListener("click", () => {
    const value = elements.output?.value?.trim();
    if (!value) {
      setStatus("No output to copy", true);
      return;
    }
    copyText(value, "output");
  });
  elements.clear?.addEventListener("click", () => {
    if (elements.input) elements.input.value = "";
    if (elements.output) elements.output.value = "";
    setStatus("Cleared input/output", false);
  });
  elements.from?.addEventListener("change", () => {
    ensureConverterMode();
    scheduleConvert(true);
  });
  elements.to?.addEventListener("change", () => {
    ensureConverterMode();
    scheduleConvert(true);
  });
  elements.input?.addEventListener("input", () => scheduleConvert());
  elements.formatInput?.addEventListener("click", () =>
    handleFormatField(elements.input, elements.from?.value, false),
  );
  elements.minifyInput?.addEventListener("click", () =>
    handleFormatField(elements.input, elements.from?.value, true),
  );
  elements.formatOutput?.addEventListener("click", () =>
    handleFormatField(elements.output, elements.to?.value, false),
  );
  elements.minifyOutput?.addEventListener("click", () =>
    handleFormatField(elements.output, elements.to?.value, true),
  );
  elements.coderInput?.addEventListener("input", () => scheduleCoder());
  elements.decodeVariant?.addEventListener("change", (event) => {
    state.selectedDecoder = event.target.value;
    updateCoderTexts();
    scheduleCoder(true);
  });
  elements.hashToggleCase?.addEventListener("click", () => {
    state.hashUppercase = !state.hashUppercase;
    elements.hashToggleCase.dataset.upper = state.hashUppercase ? "true" : "false";
    if (state.lastHashResults) {
      renderHashResults(state.lastHashResults);
    }
  });
  elements.coderResults?.addEventListener("click", (event) => {
    const toggle = event.target.closest("button[data-encode-group]");
    if (toggle) {
      const group = toggle.dataset.encodeGroup || "";
      if (group) {
        state.encodeCaseMap[group] = !state.encodeCaseMap[group];
        if (state.lastEncodeResults) {
          renderEncodeResults(state.lastEncodeResults);
        }
      }
      return;
    }
    const button = event.target.closest("button[data-value]");
    if (button) {
      const value = button.dataset.value || "";
      if (value) {
        copyText(value, button.dataset.label || "Result");
      }
      return;
    }
    const entry = event.target.closest(".coder-entry[data-copy-value]");
    if (entry) {
      const value = entry.dataset.copyValue || "";
      if (value) {
        copyText(value, entry.dataset.copyLabel || "Result");
      }
    }
  });
  elements.pairInput?.addEventListener("input", () => handlePairInput("input"));
  elements.pairOutput?.addEventListener("input", () => handlePairInput("output"));
  elements.jwtAlgorithm?.addEventListener("change", () => {
    if (state.currentTool === "coder-jwt") {
      runPairConversion("input");
    }
  });
  elements.jwtSecret?.addEventListener("input", () => {
    if (
      state.currentTool === "coder-jwt" &&
      state.pairLastSource === "input" &&
      elements.pairInput?.value.trim()
    ) {
      runPairConversion("input");
    }
  });
  elements.numberBinary?.addEventListener("input", () =>
    handleNumberInput("binary"),
  );
  elements.numberOctal?.addEventListener("input", () =>
    handleNumberInput("octal"),
  );
  elements.numberDecimal?.addEventListener("input", () =>
    handleNumberInput("decimal"),
  );
  elements.numberHex?.addEventListener("input", () =>
    handleNumberInput("hex"),
  );
  unitKeys.forEach((key) => {
    const id = `unit${capitalize(key)}`;
    elements[id]?.addEventListener("input", () => handleUnitInput(key));
  });
  elements.ipv4Input?.addEventListener("input", () => runIPv4Conversion());
  elements.ipv4Results?.addEventListener("click", (event) => {
    const target = event.target.closest("[data-copy-value]");
    if (target) {
      const toCopy = target.dataset.copyValue || "";
      if (toCopy) {
        copyText(toCopy, "IP value");
        setStatus("Copied", false);
      }
    }
  });
  elements.uuidToggleCase?.addEventListener("click", () => {
    state.uuidUppercase = !state.uuidUppercase;
    if (elements.uuidToggleCase) {
      elements.uuidToggleCase.dataset.upper = state.uuidUppercase ? "true" : "false";
    }
    renderUUIDs();
  });
  elements.uuidRegenerate?.addEventListener("click", () => refreshUUIDs(true));
  elements.uaBrowser?.addEventListener("change", () => refreshUserAgents(true));
  elements.uaOS?.addEventListener("change", () => refreshUserAgents(true));
  elements.randomLength?.addEventListener("input", handleRandomLengthChange);
  elements.randomAllowZero?.addEventListener("change", handleRandomLeadingToggle);
  elements.randomDigitToggles?.addEventListener("click", handleRandomDigitToggle);
  elements.randomGenerate?.addEventListener("click", () => runRandomGenerator());
  elements.randomResult?.addEventListener("click", () => {
    if (!state.randomResult) return;
    copyText(state.randomResult, "Random number");
    setStatus("Copied", false);
  });
}

function ensureConverterMode() {
  if (state.currentTool !== "format") return false;
  const from = elements.from?.value || "";
  const to = elements.to?.value || "";
  if (!supportedFormats.has(from) || !supportedFormats.has(to)) {
    setStatus("Unsupported format", true);
    return false;
  }
  if (elements.inputLabel) elements.inputLabel.textContent = from;
  if (elements.outputLabel) elements.outputLabel.textContent = to;
  if (elements.input) {
    elements.input.placeholder = samples[from] || "";
  }
  state.formatKey = `${from}|${to}`;
  return true;
}

function scheduleConvert(immediate = false) {
  if (state.currentTool !== "format") return;
  if (!ensureConverterMode()) return;
  if (immediate) {
    convert();
    return;
  }
  clearTimeout(convertTimer);
  convertTimer = setTimeout(() => convert(), 250);
}

function convert() {
  if (state.currentTool !== "format") return;
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
    return;
  }
  const from = elements.from?.value || "";
  const to = elements.to?.value || "";
  const text = elements.input?.value || "";
  if (!text.trim()) {
    if (elements.output) elements.output.value = "";
    setStatus("Input is empty");
    return;
  }
  try {
    const result = transform_format(from, to, text);
    if (elements.output) {
      elements.output.value = result || "";
    }
    setStatus("Done", false);
  } catch (err) {
    if (elements.output) elements.output.value = "";
    setStatus(`⚠️ ${err?.message || err}`, true);
  }
}

function handleFormatField(target, formatName, minify) {
  if (!target || state.currentTool !== "format") return;
  if (!formatName || !supportedFormats.has(formatName)) {
    setStatus("Unsupported format", true);
    return;
  }
  if (!target.value.trim()) {
    setStatus("Nothing to process", true);
    return;
  }
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
    return;
  }
  try {
    const updated = format_content_text(formatName, target.value, Boolean(minify));
    target.value = updated || "";
    setStatus(minify ? "Minified" : "Formatted", false);
  } catch (err) {
    setStatus(`⚠️ ${err?.message || err}`, true);
  }
}

function selectTool(toolId) {
  const meta = toolInfo[toolId];
  if (!meta) return;
  state.currentTool = toolId;
  elements.toolName && (elements.toolName.textContent = meta.label);
  elements.toolDesc && (elements.toolDesc.textContent = meta.description || "");
  updateBodyClasses(toolId);
  const workspaceId = meta.workspace;
  showWorkspace(workspaceId);
  toggleConverterControls(toolId === "format");
  updateToolButtons();
  if (!implementedTools.has(toolId)) {
    setStatus("This tool isn't wired up in this build.", true);
  } else {
    setStatus("Ready", false);
  }
  if (toolId === "format") {
    ensureConverterMode();
    scheduleConvert(true);
    return;
  }
  if (coderMainTools.has(toolId)) {
    const nextMode = coderToolModes[toolId] || "encode";
    const changed = state.coderMode !== nextMode;
    state.coderMode = nextMode;
    updateCoderTexts();
    if (changed) {
      renderCoderEmpty();
    }
    scheduleCoder(true);
    return;
  }
  if (isPairTool(toolId)) {
    activatePairTool(toolId);
    return;
  }
  if (isNumberTool(toolId)) {
    activateNumberTool();
    return;
  }
  if (isUnitTool(toolId)) {
    activateUnitTool();
    return;
  }
  if (isIPv4Tool(toolId)) {
    activateIPv4Tool();
    return;
  }
  if (isUUIDTool(toolId)) {
    activateUUIDTool();
  } else if (isUserAgentTool(toolId)) {
    activateUserAgentTool();
  } else if (isRandomTool(toolId)) {
    activateRandomTool();
  }
}

function updateBodyClasses(toolId) {
  document.body.classList.toggle("tool-format", toolId === "format");
  document.body.classList.toggle("tool-coder", coderMainTools.has(toolId));
  document.body.classList.toggle("tool-pair", pairTools.has(toolId));
  document.body.classList.toggle("tool-number", numberTools.has(toolId));
  document.body.classList.toggle("tool-unit", unitTools.has(toolId));
  document.body.classList.toggle("tool-ipv4", ipv4Tools.has(toolId));
  document.body.classList.toggle("tool-generator", generatorTools.has(toolId));
  document.body.classList.toggle("tool-uuid", isUUIDTool(toolId));
  document.body.classList.toggle("tool-useragent", isUserAgentTool(toolId));
  document.body.classList.toggle("tool-random", isRandomTool(toolId));
}

function toggleConverterControls(show) {
  if (elements.converterControls) {
    elements.converterControls.classList.toggle("hidden", !show);
  }
}

function showWorkspace(workspaceId) {
  workspaceIds.forEach((id) => {
    const el = document.getElementById(id);
    if (el) {
      el.classList.toggle("hidden", id !== workspaceId);
    }
  });
}

function updateToolButtons() {
  document
    .querySelectorAll("#toolGroups button")
    .forEach((btn) =>
      btn.classList.toggle("active", btn.dataset.toolId === state.currentTool),
    );
}

function setStatus(message, isError) {
  if (!elements.status) return;
  elements.status.textContent = message || "Ready";
  elements.status.classList.toggle("error", Boolean(isError));
}

function scheduleCoder(immediate = false) {
  if (!coderMainTools.has(state.currentTool)) return;
  if (immediate) {
    runCoder();
    return;
  }
  clearTimeout(coderTimer);
  coderTimer = setTimeout(() => runCoder(), 200);
}

function runCoder() {
  if (!coderMainTools.has(state.currentTool)) return;
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
    return;
  }
  const text = elements.coderInput?.value || "";
  const trimmed = text.trim();
  if (!trimmed && state.coderMode !== "hash") {
    renderCoderEmpty();
    return;
  }
  try {
    if (state.coderMode === "encode") {
      const result = encode_content(text);
      const map = normalizeMapResult(result);
      state.lastEncodeResults = map;
      renderEncodeResults(map);
      setStatus("Done", false);
      return;
    }
    if (state.coderMode === "decode") {
      const decoderKey =
        state.selectedDecoder || elements.decodeVariant?.value || "";
      if (!decoderKey) {
        setStatus("Select an encoding to decode", true);
        return;
      }
      const decodeInput =
        decoderKey === "hex_upper" ? text.toUpperCase() : text;
      const decoded = decode_content(decoderKey, decodeInput);
      const info = encodingVariantMap.get(decoderKey);
      const displayLabel = info
        ? `${info.group} · ${info.label}`
        : "Decoded";
      renderDecodeResult(decoded, displayLabel);
      setStatus("Done", false);
      return;
    }
    const hashes = hash_content(text);
    const map = normalizeMapResult(hashes);
    state.lastHashResults = map;
    renderHashResults(map);
    setStatus("Done", false);
  } catch (err) {
    renderCoderEmpty();
    setStatus(`⚠️ ${err?.message || err}`, true);
  }
}

function updateCoderTexts() {
  if (elements.coderWorkspaceTitle) {
    elements.coderWorkspaceTitle.textContent =
      coderModeTitles[state.coderMode] || state.coderMode;
  }
  if (elements.coderModeHint) {
    elements.coderModeHint.textContent =
      coderModeDescriptions[state.coderMode] || "";
  }
  if (elements.coderResultHeading) {
    const heading =
      state.coderMode === "hash"
        ? "Hash Digests"
        : state.coderMode === "decode"
          ? "Decode"
          : "Encodings";
    elements.coderResultHeading.textContent = heading;
  }
  if (elements.coderResultHint) {
    if (state.coderMode === "decode") {
      const info = encodingVariantMap.get(state.selectedDecoder);
      elements.coderResultHint.textContent = info
        ? `${info.group} · ${info.label}`
        : coderResultHints.decode;
    } else {
      elements.coderResultHint.textContent =
        coderResultHints[state.coderMode] || "";
    }
  }
  if (elements.decodeVariantWrap) {
    elements.decodeVariantWrap.classList.toggle(
      "hidden",
      state.coderMode !== "decode",
    );
  }
  if (elements.decodeVariant && state.selectedDecoder) {
    elements.decodeVariant.value = state.selectedDecoder;
  }
  if (elements.hashToggleCase) {
    const showToggle = state.coderMode === "hash";
    elements.hashToggleCase.classList.toggle("hidden", !showToggle);
    if (showToggle) {
      elements.hashToggleCase.dataset.upper = state.hashUppercase
        ? "true"
        : "false";
    }
  }
  if (elements.coderInput) {
    elements.coderInput.placeholder =
      coderPlaceholders[state.coderMode] || coderPlaceholders.encode;
  }
  updateCoderActionsVisibility();
}

function renderCoderEmpty() {
  if (!elements.coderResults) return;
  if (state.coderMode === "hash") {
    state.lastHashResults = null;
  }
  if (state.coderMode === "encode") {
    state.lastEncodeResults = null;
  }
  const message =
    state.coderMode === "decode"
      ? "Paste encoded text to decode"
      : "Enter content to see results";
  elements.coderResults.innerHTML = `<div class="muted">${message}</div>`;
}

function updateCoderActionsVisibility() {
  if (!elements.coderResultActions) return;
  const show = state.coderMode === "hash" && !elements.hashToggleCase?.classList.contains("hidden");
  elements.coderResultActions.classList.toggle("hidden", !show);
}

function renderEncodeResults(map) {
  if (!elements.coderResults) return;
  const blocks = encodingGroups
    .map((group) => {
      let toggleInjected = false;
      const entries = group.variants
        .map((variant) => {
          const raw = map?.[variant.key];
          if (typeof raw !== "string") {
            return null;
          }
          let displayValue = raw;
          let toggleGroup = null;
          if (group.id === "base16") {
            const upper = state.encodeCaseMap.base16 !== false;
            displayValue = upper ? raw.toUpperCase() : raw.toLowerCase();
            if (!toggleInjected) {
              toggleGroup = "base16";
              toggleInjected = true;
            }
          } else if (group.id === "base32") {
            const upper = state.encodeCaseMap.base32 !== false;
            displayValue = upper ? raw.toUpperCase() : raw.toLowerCase();
            if (!toggleInjected) {
              toggleGroup = "base32";
              toggleInjected = true;
            }
          }
          return {
            label: variant.label,
            value: displayValue,
            copyLabel: `${group.label} · ${variant.label}`,
            clickCopy: true,
            toggleGroup,
          };
        })
        .filter(Boolean);
      if (!entries.length) {
        return "";
      }
      return renderGroupBlock(group.label, entries);
    })
    .filter(Boolean);
  if (!blocks.length) {
    renderCoderEmpty();
    return;
  }
  elements.coderResults.innerHTML = `
    <div class="coder-groups">
      <div class="coder-output-grid">${blocks.join("")}</div>
    </div>
  `;
}

function renderDecodeResult(value, label) {
  if (!elements.coderResults) return;
  const block = renderGroupBlock(label || "Decoded", [
    {
      label: label || "Decoded",
      value: value || "",
      copyLabel: label || "Decoded",
    },
  ]);
  elements.coderResults.innerHTML = `
    <div class="coder-groups">
      <div class="coder-output-grid">${block}</div>
    </div>
  `;
}

function renderHashResults(map) {
  if (!elements.coderResults) return;
  const blocks = hashGroups
    .map((group) => {
      const entries = group.keys
        .map((key) => {
          const raw = map?.[key];
          if (typeof raw !== "string") {
            return null;
          }
          const label = hashLabels[key] || key;
          const value = state.hashUppercase ? raw.toUpperCase() : raw.toLowerCase();
          return {
            label,
            value,
            copyLabel: label,
            clickCopy: true,
          };
        })
        .filter(Boolean);
      if (!entries.length) return "";
      return renderGroupBlock(group.label, entries);
    })
    .filter(Boolean);
  if (!blocks.length) {
    renderCoderEmpty();
    return;
  }
  elements.coderResults.innerHTML = `
    <div class="coder-groups">
      <div class="coder-output-grid">${blocks.join("")}</div>
    </div>
  `;
}

function renderGroupBlock(title, entries) {
  if (!entries.length) return "";
  const rows = entries.map((entry) => renderEntryRow(entry)).join("");
  const safeTitle = escapeHTML(title || "Result");
  return `
    <section class="coder-output-block">
      <header>${safeTitle}</header>
      <div class="coder-output-entries">
        ${rows}
      </div>
    </section>
  `;
}

function renderEntryRow(entry) {
  const clickable = !!entry.clickCopy;
  const safeLabel = escapeHTML(entry.label || "Result");
  const safeValue = escapeHTML(entry.value || "");
  const attrValue = escapeAttr(entry.value || "");
  const buttonLabel = escapeAttr(entry.copyLabel || entry.label || "Result");
  const entryAttrs = clickable
    ? `class="coder-entry click-copy" data-copy-value="${attrValue}" data-copy-label="${buttonLabel}"`
    : `class="coder-entry"`;
  const toggleGroup = entry.toggleGroup || null;
  let actionMarkup = "";
  if (toggleGroup) {
    const upperActive = state.encodeCaseMap[toggleGroup] !== false;
    actionMarkup = `<button type="button" data-encode-group="${toggleGroup}" data-upper="${upperActive ? "true" : "false"}">Toggle Case</button>`;
  } else if (clickable) {
    actionMarkup = '<span class="copy-hint">Click to copy</span>';
  } else {
    actionMarkup = `<button type="button" data-label="${buttonLabel}" data-value="${attrValue}">Copy</button>`;
  }
  return `
    <div ${entryAttrs}>
      <div class="coder-entry-meta">
        <span>${safeLabel}</span>
        ${actionMarkup}
      </div>
      <textarea readonly spellcheck="false">${safeValue}</textarea>
    </div>
  `;
}

function isUUIDTool(toolId) {
  return uuidToolSet.has(toolId);
}

function isUserAgentTool(toolId) {
  return userAgentToolSet.has(toolId);
}

function isPairTool(toolId) {
  return pairTools.has(toolId);
}

function isNumberTool(toolId) {
  return numberTools.has(toolId);
}

function isUnitTool(toolId) {
  return unitTools.has(toolId);
}

function isIPv4Tool(toolId) {
  return ipv4Tools.has(toolId);
}

function isRandomTool(toolId) {
  return randomToolSet.has(toolId);
}

function activatePairTool(toolId) {
  state.currentPairTool = toolId;
  state.pairLastSource = "input";
  const config = pairToolConfigs[toolId];
  if (!config) {
    setStatus("This tool isn't wired up in this build.", true);
    return;
  }
  if (elements.pairInputLabel) {
    elements.pairInputLabel.textContent = config.inputLabel || "Encode";
  }
  if (elements.pairOutputLabel) {
    elements.pairOutputLabel.textContent = config.outputLabel || "Decode";
  }
  if (elements.pairInputHint) {
    elements.pairInputHint.textContent = config.inputHint || "";
  }
  if (elements.pairOutputHint) {
    elements.pairOutputHint.textContent = config.outputHint || "";
  }
  if (elements.pairInput) {
    elements.pairInput.placeholder = config.inputPlaceholder || "";
    elements.pairInput.value = "";
  }
  if (elements.pairOutput) {
    elements.pairOutput.placeholder = config.outputPlaceholder || "";
    elements.pairOutput.value = "";
  }
  const showJWT = config.type === "jwt";
  elements.jwtControls?.classList.toggle("hidden", !showJWT);
  if (!showJWT) {
    if (elements.jwtSecret) {
      elements.jwtSecret.value = "";
    }
    updatePairMeta(null);
  } else if (elements.jwtAlgorithm && !elements.jwtAlgorithm.value) {
    elements.jwtAlgorithm.value = "HS256";
  }
  updatePairMeta(null);
  setStatus("Ready", false);
}

function handlePairInput(source) {
  if (!isPairTool(state.currentTool) || state.pairSyncing) return;
  runPairConversion(source);
}

function runPairConversion(source) {
  if (!isPairTool(state.currentTool)) return;
  const config = pairToolConfigs[state.currentTool];
  if (!config) {
    setStatus("This tool isn't wired up in this build.", true);
    return;
  }
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
    return;
  }
  state.pairLastSource = source;
  const inputValue = elements.pairInput?.value || "";
  const outputValue = elements.pairOutput?.value || "";
  if (config.type === "url") {
    if (source === "input") {
      if (!inputValue) {
        setPairField(elements.pairOutput, "");
        setStatus("Cleared");
        return;
      }
      try {
        const encoded = url_encode(inputValue);
        setPairField(elements.pairOutput, encoded);
        setStatus("Done", false);
      } catch (err) {
        setStatus(`⚠️ ${err?.message || err}`, true);
      }
      return;
    }
    if (!outputValue) {
      setPairField(elements.pairInput, "");
      setStatus("Cleared");
      return;
    }
    try {
      const decoded = url_decode(outputValue);
      setPairField(elements.pairInput, decoded);
      setStatus("Done", false);
    } catch (err) {
      setStatus(`⚠️ ${err?.message || err}`, true);
    }
    return;
  }
  if (config.type === "jwt") {
    if (source === "input") {
      if (!inputValue.trim()) {
        setPairField(elements.pairOutput, "");
        updatePairMeta(null);
        setStatus("Cleared");
        return;
      }
      const secret = elements.jwtSecret?.value || "";
      if (!secret.trim()) {
        setStatus("Secret is required", true);
        return;
      }
      const algorithm = elements.jwtAlgorithm?.value || "HS256";
      try {
        const token = jwt_encode(inputValue, secret, algorithm);
        setPairField(elements.pairOutput, token);
        updatePairMeta(null);
        setStatus("Done", false);
      } catch (err) {
        setStatus(`⚠️ ${err?.message || err}`, true);
      }
      return;
    }
    if (!outputValue.trim()) {
      setPairField(elements.pairInput, "");
      updatePairMeta(null);
      setStatus("Cleared");
      return;
    }
    try {
      const info = jwt_decode(outputValue) || {};
      if (info.payload && elements.pairInput) {
        setPairField(elements.pairInput, info.payload);
      }
      if (info.algorithm && elements.jwtAlgorithm) {
        elements.jwtAlgorithm.value = info.algorithm;
      }
      updatePairMeta(info);
      setStatus("Done", false);
    } catch (err) {
      setStatus(`⚠️ ${err?.message || err}`, true);
    }
    return;
  }
  if (config.type === "markdown") {
    if (source === "input") {
      if (!inputValue.trim()) {
        setPairField(elements.pairOutput, "");
        setStatus("Cleared");
        return;
      }
      try {
        const html = markdown_to_html_text(inputValue);
        setPairField(elements.pairOutput, html || "");
        setStatus("Done", false);
      } catch (err) {
        setStatus(`⚠️ ${err?.message || err}`, true);
      }
      return;
    }
    if (!outputValue.trim()) {
      setPairField(elements.pairInput, "");
      setStatus("Cleared");
      return;
    }
    try {
      const markdown = html_to_markdown_text(outputValue);
      setPairField(elements.pairInput, markdown || "");
      setStatus("Done", false);
    } catch (err) {
      setStatus(`⚠️ ${err?.message || err}`, true);
    }
    return;
  }
  setStatus("This tool isn't wired up in this build.", true);
}

function setPairField(target, value) {
  if (!target) return;
  state.pairSyncing = true;
  target.value = value || "";
  state.pairSyncing = false;
}

function updatePairMeta(info) {
  if (!elements.pairOutputMeta) return;
  if (!info || state.currentTool !== "coder-jwt") {
    elements.pairOutputMeta.classList.add("hidden");
    elements.pairOutputMeta.textContent = "";
    return;
  }
  const sections = [];
  if (info.header) {
    sections.push(`Header:\n${info.header}`);
  }
  if (info.signature) {
    sections.push(`Signature:\n${info.signature}`);
  }
  elements.pairOutputMeta.textContent = sections.join("\n\n");
  elements.pairOutputMeta.classList.toggle("hidden", sections.length === 0);
}

function activateNumberTool() {
  state.numberSyncing = true;
  [elements.numberBinary, elements.numberOctal, elements.numberDecimal, elements.numberHex].forEach(
    (field) => {
      if (field) field.value = "";
    },
  );
  state.numberSyncing = false;
  setStatus("Ready", false);
}

function handleNumberInput(base) {
  if (!isNumberTool(state.currentTool) || state.numberSyncing) return;
  runNumberConversion(base);
}

function runNumberConversion(base) {
  const fieldName = `number${capitalize(base)}`;
  const field = elements[fieldName];
  if (!field) return;
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
    return;
  }
  const value = field.value;
  if (!value.trim()) {
    state.numberSyncing = true;
    [elements.numberBinary, elements.numberOctal, elements.numberDecimal, elements.numberHex].forEach(
      (input) => {
        if (input) input.value = "";
      },
    );
    state.numberSyncing = false;
    setStatus("Cleared");
    return;
  }
  try {
    const result = convert_number_base(base, value) || {};
    state.numberSyncing = true;
    if (typeof result.binary === "string" && elements.numberBinary) {
      elements.numberBinary.value = result.binary;
    }
    if (typeof result.octal === "string" && elements.numberOctal) {
      elements.numberOctal.value = result.octal;
    }
    if (typeof result.decimal === "string" && elements.numberDecimal) {
      elements.numberDecimal.value = result.decimal;
    }
    if (typeof result.hex === "string" && elements.numberHex) {
      elements.numberHex.value = result.hex;
    }
    state.numberSyncing = false;
    setStatus("Done", false);
  } catch (err) {
    state.numberSyncing = false;
    setStatus(`⚠️ ${err?.message || err}`, true);
  }
}

function activateUnitTool() {
  clearUnitFields();
  setStatus("Ready", false);
}

function handleUnitInput(unitKey) {
  if (!isUnitTool(state.currentTool) || state.unitSyncing) return;
  runUnitConversion(unitKey);
}

function runUnitConversion(unitKey) {
  const fieldId = `unit${capitalize(unitKey)}`;
  const field = elements[fieldId];
  if (!field) return;
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
    return;
  }
  const value = field.value;
  if (!value.trim()) {
    clearUnitFields();
    setStatus("Cleared");
    return;
  }
  try {
    const result = convert_units(unitKey, value);
    const normalized = normalizeMapResult(result);
    state.unitSyncing = true;
    unitKeys.forEach((key) => {
      const target = elements[`unit${capitalize(key)}`];
      if (target && typeof normalized[key] === "string") {
        target.value = normalized[key];
      }
    });
    state.unitSyncing = false;
    setStatus("Done", false);
  } catch (err) {
    state.unitSyncing = false;
    setStatus(`⚠️ ${err?.message || err}`, true);
  }
}

function clearUnitFields() {
  state.unitSyncing = true;
  unitKeys.forEach((key) => {
    const target = elements[`unit${capitalize(key)}`];
    if (target) target.value = "";
  });
  state.unitSyncing = false;
}

function activateIPv4Tool() {
  if (elements.ipv4Results) {
    elements.ipv4Results.innerHTML =
      '<div class="muted">Enter an IP address (IPv4/IPv6), CIDR block, or range to see details</div>';
  }
  if (elements.ipv4Input) {
    elements.ipv4Input.value = "";
  }
  setStatus("Ready", false);
}

function runIPv4Conversion() {
  if (!isIPv4Tool(state.currentTool)) return;
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
    return;
  }
  const value = elements.ipv4Input?.value.trim() || "";
  if (!value) {
    if (elements.ipv4Results) {
      elements.ipv4Results.innerHTML =
        '<div class="muted">Enter an IP address (IPv4/IPv6), CIDR block, or range to see details</div>';
    }
    setStatus("Cleared");
    return;
  }
  try {
    const data = ipv4_info(value) || {};
    renderIPv4Results(data);
    setStatus("Done", false);
  } catch (err) {
    setStatus(`⚠️ ${err?.message || err}`, true);
  }
}

function renderIPv4Results(data) {
  if (!elements.ipv4Results) return;
  const stats = [];
  const addRow = (label, value) => {
    if (!value) return;
    stats.push(renderIPv4Row(label, value));
  };
  addRow("Version", data.version);
  addRow("Type", data.type);
  addRow("Standard", data.standard);
  addRow("CIDR", data.cidr);
  addRow("Mask", data.mask);
  addRow("Mask (binary)", data.maskBinary);
  if (data.rangeStart || data.rangeEnd) {
    addRow("Range", `${data.rangeStart || "?"} → ${data.rangeEnd || "?"}`);
  }
  addRow("Network", data.network);
  addRow("Broadcast", data.broadcast);
  addRow("Total IPs", data.total);
  addRow("3-part", data.threePart);
  addRow("2-part", data.twoPart);
  addRow("Integer", data.integer);
  addRow("Expanded", data.expanded);
  addRow("Compressed", data.compressed);
  addRow("Binary", data.binary);
  addRow("Host bits", data.hostBits);
  if (!stats.length) {
    elements.ipv4Results.innerHTML =
      '<div class="muted">Unable to parse input</div>';
    return;
  }
  elements.ipv4Results.innerHTML = `<div class="ipv4-stats">${stats.join("")}</div>`;
}

function renderIPv4Row(label, value) {
  const safeLabel = escapeHTML(label || "");
  const safeValue = escapeHTML(value || "");
  const attrValue = escapeAttr(value || "");
  return `
    <div class="stat">
      <span>${safeLabel}</span>
      <span class="click-copy" data-copy-value="${attrValue}">${safeValue}</span>
    </div>
  `;
}

function activateUUIDTool() {
  state.uuidUppercase = false;
  if (elements.uuidToggleCase) {
    elements.uuidToggleCase.dataset.upper = "false";
  }
  if (!state.wasmReady) {
    if (elements.uuidList) {
      elements.uuidList.innerHTML =
        '<div class="muted">Waiting for WebAssembly...</div>';
    }
    return;
  }
  refreshUUIDs(true);
}

function refreshUUIDs(force = false) {
  if (!isUUIDTool(state.currentTool) || !state.wasmReady) return;
  if (!force && Object.keys(state.currentUUIDs).length) {
    renderUUIDs();
    return;
  }
  try {
    const result = generate_uuids();
    state.currentUUIDs = normalizeUuidResult(result);
    renderUUIDs();
    setStatus("Generated new UUIDs", false);
  } catch (err) {
    console.error(err);
    setStatus(`⚠️ ${err.message}`, true);
  }
}

function renderUUIDs() {
  if (!elements.uuidList) return;
  const entries = [];
  const seen = new Set();
  uuidDisplayOrder.forEach((key) => {
    if (state.currentUUIDs[key]) {
      entries.push([key, state.currentUUIDs[key]]);
      seen.add(key);
    }
  });
  Object.keys(state.currentUUIDs).forEach((key) => {
    if (!seen.has(key)) {
      entries.push([key, state.currentUUIDs[key]]);
    }
  });
  if (!entries.length) {
    elements.uuidList.innerHTML =
      '<div class="muted">No UUIDs generated yet</div>';
    return;
  }
  const rows = entries
    .map(([version, value]) => {
      const display = state.uuidUppercase
        ? value.toUpperCase()
        : value.toLowerCase();
      const label = uuidDisplayLabels[version] || version.toUpperCase();
      return `
        <div class="uuid-row" data-value="${escapeAttr(display)}" data-label="${escapeAttr(label)}">
          <span>${label}</span>
          <code>${escapeHTML(display)}</code>
          <button type="button" class="uuid-copy">Copy</button>
        </div>
      `;
    })
    .join("");
  elements.uuidList.innerHTML = rows;
  elements.uuidList.querySelectorAll(".uuid-copy").forEach((btn) => {
    btn.addEventListener("click", () => {
      const row = btn.closest(".uuid-row");
      if (!row) return;
      const value = row.dataset.value || "";
      const label = row.dataset.label || "UUID";
      if (!value) return;
      copyText(value, label);
    });
  });
}

function activateUserAgentTool() {
  state.currentBrowserFilter = elements.uaBrowser?.value || "";
  state.currentOSFilter = elements.uaOS?.value || "";
  if (!state.wasmReady) {
    if (elements.uaResults) {
      elements.uaResults.innerHTML =
        '<div class="muted">Waiting for WebAssembly...</div>';
    }
    return;
  }
  refreshUserAgents(true);
}

function refreshUserAgents(force = false) {
  if (!isUserAgentTool(state.currentTool) || !state.wasmReady) return;
  const browser = elements.uaBrowser?.value || "";
  const os = elements.uaOS?.value || "";
  const sameFilters =
    browser === state.currentBrowserFilter && os === state.currentOSFilter;
  if (!force && sameFilters && state.currentUserAgents.length) {
    renderUserAgents(state.currentUserAgents);
    return;
  }
  state.currentBrowserFilter = browser;
  state.currentOSFilter = os;
  try {
    const list = generate_user_agents(browser, os);
    state.currentUserAgents = Array.isArray(list) ? list : [];
    renderUserAgents(state.currentUserAgents);
    setStatus("Generated user agents", false);
  } catch (err) {
    console.error(err);
    setStatus(`⚠️ ${err.message}`, true);
  }
}

function renderUserAgents(list) {
  if (!elements.uaResults) return;
  if (!list.length) {
    elements.uaResults.innerHTML =
      '<div class="muted">No user agents for this filter</div>';
    return;
  }
  const cards = list
    .map((entry) => {
      const browserName = entry.browserName || "Unknown";
      const browserVersion = entry.browserVersion || "";
      const osName = entry.osName || "Unknown";
      const osVersion = entry.osVersion || "";
      const engineName = entry.engineName || "Unknown";
      const engineVersion = entry.engineVersion || "";
      const browserText = browserVersion
        ? `${browserName} ${browserVersion}`
        : browserName;
      const osText = osVersion ? `${osName} ${osVersion}` : osName;
      const engineText = engineVersion
        ? `${engineName} ${engineVersion}`
        : engineName;
      const ua = entry.userAgent || "";
      return `
        <div class="ua-card" data-ua="${escapeAttr(ua)}" title="Click to copy">
          <code>${escapeHTML(ua)}</code>
          <div class="ua-meta">
            <span><strong>Browser:</strong> ${escapeHTML(browserText)}</span>
            <span><strong>OS:</strong> ${escapeHTML(osText)}</span>
            <span><strong>Engine:</strong> ${escapeHTML(engineText)}</span>
          </div>
        </div>
      `;
    })
    .join("");
  elements.uaResults.innerHTML = cards;
  elements.uaResults.querySelectorAll(".ua-card").forEach((card) => {
    card.addEventListener("click", () => {
      const value = card.dataset.ua || "";
      if (!value) return;
      copyText(value, "user agent");
    });
  });
}

function activateRandomTool() {
  syncRandomDigitButtons();
  if (elements.randomLength) {
    elements.randomLength.value = state.randomLength;
  }
  if (elements.randomAllowZero) {
    elements.randomAllowZero.checked = state.randomAllowLeadingZero;
  }
  updateRandomResult(state.randomResult);
  setStatus("Ready", false);
}

function handleRandomLengthChange() {
  if (!elements.randomLength) return;
  let value = parseInt(elements.randomLength.value, 10);
  if (!Number.isFinite(value)) {
    value = 1;
  }
  value = Math.min(Math.max(value, 1), 2048);
  state.randomLength = value;
  elements.randomLength.value = value;
}

function handleRandomLeadingToggle(event) {
  state.randomAllowLeadingZero = Boolean(event?.target?.checked);
}

function handleRandomDigitToggle(event) {
  const button = event.target.closest("button[data-digit]");
  if (!button || !elements.randomDigitToggles) return;
  const digit = button.dataset.digit;
  if (!digitChoices.includes(digit)) return;
  const active = button.dataset.active !== "false";
  if (active) {
    if (state.randomDigits.size === 1) {
      setStatus("Keep at least one digit", true);
      return;
    }
    state.randomDigits.delete(digit);
    button.dataset.active = "false";
  } else {
    state.randomDigits.add(digit);
    button.dataset.active = "true";
  }
}

function syncRandomDigitButtons() {
  if (!elements.randomDigitToggles) return;
  if (!state.randomDigits || state.randomDigits.size === 0) {
    state.randomDigits = new Set(digitChoices);
  }
  elements.randomDigitToggles
    .querySelectorAll("button[data-digit]")
    .forEach((button) => {
      const digit = button.dataset.digit;
      const isActive = state.randomDigits.has(digit);
      button.dataset.active = isActive ? "true" : "false";
    });
}

function runRandomGenerator() {
  if (!isRandomTool(state.currentTool)) {
    setStatus("Select the Random Number tool", true);
    return;
  }
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
    return;
  }
  handleRandomLengthChange();
  const digits = Array.from(state.randomDigits).sort();
  if (!digits.length) {
    setStatus("Select at least one digit", true);
    return;
  }
  try {
    const result = random_number_string(
      state.randomLength,
      state.randomAllowLeadingZero,
      digits.join("") || "0123456789",
    );
    updateRandomResult(result);
    setStatus("Done", false);
  } catch (err) {
    updateRandomResult("");
    setStatus(`⚠️ ${err?.message || err}`, true);
  }
}

function updateRandomResult(value) {
  state.randomResult = value || "";
  if (!elements.randomResult) return;
  if (state.randomResult) {
    elements.randomResult.textContent = state.randomResult;
    elements.randomResult.dataset.copyValue = state.randomResult;
    elements.randomResult.classList.remove("empty");
  } else {
    elements.randomResult.textContent = "Click Generate to produce a number";
    elements.randomResult.dataset.copyValue = "";
    elements.randomResult.classList.add("empty");
  }
}

async function copyText(value, label) {
  try {
    await navigator.clipboard.writeText(value);
    setStatus(`Copied ${label}`, false);
  } catch (err) {
    console.error(err);
    setStatus("Unable to access clipboard", true);
  }
}

function escapeHTML(value = "") {
  return value
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;");
}

function escapeAttr(value = "") {
  return escapeHTML(value).replace(/'/g, "&#39;");
}

function normalizeUuidResult(value) {
  return normalizeMapResult(value);
}

function normalizeMapResult(value) {
  if (!value) {
    return {};
  }
  if (value instanceof Map) {
    const record = {};
    value.forEach((val, key) => {
      record[String(key)] = typeof val === "string" ? val : String(val ?? "");
    });
    return record;
  }
  if (typeof value === "object" && !Array.isArray(value)) {
    const record = {};
    Object.keys(value).forEach((key) => {
      const val = value[key];
      record[key] = typeof val === "string" ? val : String(val ?? "");
    });
    return record;
  }
  return {};
}

function capitalize(text) {
  if (!text) return "";
  return text.charAt(0).toUpperCase() + text.slice(1);
}
