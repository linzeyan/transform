// Front-end controller for the Rust/Wasm toolkit. Each workspace (converter,
// coder, IPv4, SQL inserts, etc.) communicates with wasm exports so the UI can
// stay deterministic and reflect the behaviors described in the spec session.
import initWasm, {
  generate_uuids,
  generate_user_agents,
  convert_number_base,
  convert_units,
  ipv4_info,
  url_encode,
  url_decode,
  jwt_encode,
  jwt_decode,
  encode_content,
  decode_content,
  hash_content,
  hash_content_hmac,
  transform_format,
  format_content_text,
  markdown_to_html_text,
  html_to_markdown_text,
  random_number_sequences,
  generate_insert_statements,
  inspect_schema,
  convert_timestamp,
  totp_token,
  bcrypt_hash,
  bcrypt_verify,
  argon2_hash,
  argon2_verify,
} from "./pkg/wasm_core.js";

const formats = [
  "JSON",
  "Go Struct",
  "YAML",
  "TOML",
  "XML",
  "JSON Schema",
  "GraphQL Schema",
  "Protobuf",
  "TOON",
  "MsgPack",
];

const samples = {
  JSON: '{\n  "name": "Ricky",\n  "age": 27\n}',
  XML: `<root>\n  <name>Ricky</name>\n  <age>27</age>\n</root>`,
  "Go Struct":
    'type AutoGenerated struct {\n  UserID string `json:"user_id"`\n}\n',
  YAML: "name: Ricky\nage: 27",
  TOML: 'name = "Ricky"\nage = 27',
  "JSON Schema": `{
  "type": "object",
  "properties": {
    "name": { "type": "string" },
    "age": { "type": "number" }
  },
  "required": ["name"]
}`,
  "GraphQL Schema": `type AutoGenerated {
  userID: String!
}`,
  Protobuf: `message AutoGenerated {
  string user_id = 1;
}`,
  TOON: `users[2]{id,name}:
  1,Alice
  2,Bob`,
  MsgPack: "Paste base64 MsgPack here...",
};

const supportedFormats = new Set(formats);

const unitKeys = [
  "bit",
  "byte",
  "kilobit",
  "kilobyte",
  "megabit",
  "megabyte",
  "gigabit",
  "gigabyte",
  "terabit",
  "terabyte",
];

const timestampFields = [
  { key: "iso8601", id: "timestampIso" },
  { key: "rfc2822", id: "timestampRfc" },
  { key: "sql_datetime", id: "timestampSql" },
  { key: "sql_date", id: "timestampSqlDate" },
  { key: "timestamp_seconds", id: "timestampSeconds" },
  { key: "timestamp_milliseconds", id: "timestampMillis" },
  { key: "timestamp_microseconds", id: "timestampMicros" },
  { key: "timestamp_nanoseconds", id: "timestampNanos" },
];

const digitCharacters = "0123456789";
const specialCharacters = [
  "!",
  "@",
  "#",
  "$",
  "%",
  "^",
  "&",
  "*",
  "-",
  "_",
  "+",
  "=",
  "~",
  "?",
  "/",
  "\\",
  "|",
  "[",
  "]",
  "(",
  ")",
  "{",
  "}",
  "'",
  '"',
  ".",
  ",",
  ":",
  ";",
  "`",
];

const minCountConfig = {
  digits: {
    stateKey: "randomMinDigits",
    elementKey: "randomMinDigits",
  },
  lower: {
    stateKey: "randomMinLower",
    elementKey: "randomMinLower",
  },
  upper: {
    stateKey: "randomMinUpper",
    elementKey: "randomMinUpper",
  },
  symbols: {
    stateKey: "randomMinSymbols",
    elementKey: "randomMinSymbols",
  },
};

const coderTools = [
  {
    id: "coder-encode",
    mode: "encode",
    label: "Base Encoders",
    description: "Base32/64/85/91 encodings.",
  },
  {
    id: "coder-decode",
    mode: "decode",
    label: "Base Decoders",
    description: "Decode BaseX back to plain text.",
  },
  {
    id: "coder-hash",
    mode: "hash",
    label: "Hash",
    description: "Hashes from stdlib.",
  },
  {
    id: "coder-url",
    pair: "url",
    label: "URL Encode/Decode",
    description: "Bidirectional URL percent-encoding helper.",
  },
  {
    id: "coder-jwt",
    pair: "jwt",
    label: "JWT Encode/Decode",
    description: "Sign JSON payloads and inspect JWT tokens.",
  },
  {
    id: "coder-kdf",
    mode: "kdf",
    label: "Password Hashers",
    description: "Bcrypt / Argon2 generate and verify.",
  },
];

const coderToolModes = {
  "coder-encode": "encode",
  "coder-decode": "decode",
  "coder-hash": "hash",
};

const encodingGroups = [
  {
    id: "base16",
    label: "Base16",
    variants: [{ key: "hex_upper", label: "Hex" }],
  },
  {
    id: "base32",
    label: "Base32",
    variants: [
      { key: "base32_standard", label: "Standard" },
      { key: "base32_standard_no_padding", label: "Standard(no padding)" },
      { key: "base32_hex", label: "Hex" },
      { key: "base32_hex_no_padding", label: "Hex(no padding)" },
    ],
  },
  {
    id: "base64",
    label: "Base64",
    variants: [
      { key: "base64_standard", label: "Standard" },
      { key: "base64_raw_standard", label: "Standard(no padding)" },
      { key: "base64_url", label: "URL-safe" },
      { key: "base64_raw_url", label: "URL-safe(no padding)" },
    ],
  },
  {
    id: "base85",
    label: "Base85",
    variants: [{ key: "base85_ascii85", label: "ASCII85" }],
  },
  {
    id: "base91",
    label: "Base91",
    variants: [{ key: "base91", label: "Standard" }],
  },
];

const encodingVariantMap = new Map();
const allEncodingVariants = [];
encodingGroups.forEach((group) => {
  group.variants.forEach((variant) => {
    encodingVariantMap.set(variant.key, {
      group: group.label,
      label: variant.label,
    });
    allEncodingVariants.push({ ...variant, group: group.label });
  });
});

const hashGroups = [
  { label: "Message Digest", keys: ["md5", "sha1"] },
  {
    label: "SHA-2",
    keys: ["sha224", "sha256", "sha384", "sha512", "sha512_224", "sha512_256"],
  },
  {
    label: "SHA-3",
    keys: ["sha3_224", "sha3_256", "sha3_384", "sha3_512"],
  },
  {
    label: "Checksums",
    keys: [
      "crc32_ieee",
      "crc32_castagnoli",
      "crc64_iso",
      "crc64_ecma",
      "adler32",
    ],
  },
  {
    label: "FNV",
    keys: ["fnv32", "fnv32a", "fnv64", "fnv64a", "fnv128", "fnv128a"],
  },
];

const hashLabels = {
  md5: "MD5",
  sha1: "SHA-1",
  sha224: "SHA-224",
  sha256: "SHA-256",
  sha384: "SHA-384",
  sha512: "SHA-512",
  sha512_224: "SHA-512/224",
  sha512_256: "SHA-512/256",
  crc32_ieee: "CRC32 (IEEE)",
  crc32_castagnoli: "CRC32 (Castagnoli)",
  crc64_iso: "CRC64 (ISO)",
  crc64_ecma: "CRC64 (ECMA)",
  adler32: "Adler32",
  fnv32: "FNV-1 32",
  fnv32a: "FNV-1a 32",
  fnv64: "FNV-1 64",
  fnv64a: "FNV-1a 64",
  fnv128: "FNV-1 128",
  fnv128a: "FNV-1a 128",
  sha3_224: "SHA3-224",
  sha3_256: "SHA3-256",
  sha3_384: "SHA3-384",
  sha3_512: "SHA3-512",
};

const coderModeDescriptions = {
  encode: "Encode text into multiple bases.",
  decode: "Decode text with your selected base.",
  hash: "Generate hashes provided by standard library.",
};

const coderModeTitles = {
  encode: "Encode",
  decode: "Decode",
  hash: "Hash",
};

const coderResultHints = {
  encode: "Base32 / Base64 / Base85 / Base91 / Hex",
  decode: "Decoded output",
  hash: "MD5 / SHA / CRC / FNV",
};

const coderPlaceholders = {
  encode: "Type or paste text...",
  decode: "Paste Base32/64/85/91 text to decode...",
  hash: "Enter text to compute hashes",
};

const pairToolConfigs = {
  "coder-url": {
    type: "url",
    inputLabel: "URL Encode",
    inputHint: "Enter original text to URL-encode.",
    inputPlaceholder: "https://example.com/search?q=Taipei 101",
    outputLabel: "URL Decode",
    outputHint: "Paste encoded text to decode automatically.",
    outputPlaceholder: "https%3A%2F%2Fexample.com%2Fsearch%3Fq%3DTaipei101",
  },
  "coder-jwt": {
    type: "jwt",
    inputLabel: "JWT Payload (JSON)",
    inputHint:
      "Enter payload JSON; token is generated using the selected algorithm.",
    inputPlaceholder: '{\n  "sub": "1234567890",\n  "name": "John Doe"\n}',
    outputLabel: "JWT Token",
    outputHint: "Paste a JWT token to decode.",
    outputPlaceholder: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9....",
  },
  "converter-html-md": {
    type: "markdown",
    inputLabel: "Markdown → HTML",
    inputHint: "Enter Markdown to render HTML on the right.",
    inputPlaceholder: "# Title\n\n- item 1\n- item 2",
    outputLabel: "HTML → Markdown",
    outputHint: "Paste HTML to convert back to Markdown.",
    outputPlaceholder: "<h1>Title</h1>",
  },
};

const toolGroups = [
  {
    name: "Converter",
    tools: [
      {
        id: "format",
        label: "Format Converter",
        description: "Convert between structured data formats.",
      },
      {
        id: "converter-html-md",
        label: "HTML ↔ Markdown",
        description: "Convert between Markdown and HTML.",
      },
      {
        id: "converter-number-bases",
        label: "Number Bases",
        description: "Binary / Octal / Decimal / Hex conversions.",
      },
      {
        id: "converter-units",
        label: "Unit Converter",
        description: "Bits, Bytes, and binary multiples.",
      },
      {
        id: "converter-timestamp",
        label: "Timestamp Converter",
        description: "Convert Unix timestamps and date formats.",
      },
      {
        id: "converter-ipv4",
        label: "IP Tools",
        description: "IPv4/IPv6 helpers for CIDR, ranges, and formats.",
      },
    ],
  },
  {
    name: "Coder",
    tools: coderTools.map((tool) => ({
      id: tool.id,
      label: tool.label,
      description: tool.description,
    })),
  },
  {
    name: "Generator",
    tools: [
      {
        id: "generator-uuid",
        label: "UUID",
        description: "Generate UUID v1-v8, GUID, and ULID.",
      },
      {
        id: "generator-useragent",
        label: "User-Agent",
        description: "Generate realistic browser user agents.",
      },
      {
        id: "generator-random",
        label: "Random",
        description: "Random strings with customizable charset.",
      },
      {
        id: "generator-totp",
        label: "TOTP",
        description: "Time-based one-time passwords.",
      },
      {
        id: "generator-sql",
        label: "SQL Inserts",
        description: "Generate INSERT statements from MySQL schema.",
      },
    ],
  },
  {
    name: "Fingerprint",
    tools: [
      {
        id: "fingerprint-browser",
        label: "Browser Fingerprint",
        description: "Show readable browser/device hints.",
      },
    ],
  },
];

const workspaceByTool = {
  format: "converterWorkspace",
  "converter-html-md": "pairWorkspace",
  "converter-number-bases": "numberWorkspace",
  "converter-units": "unitWorkspace",
  "converter-timestamp": "timestampWorkspace",
  "converter-ipv4": "ipv4Workspace",
  "coder-encode": "coderWorkspace",
  "coder-decode": "coderWorkspace",
  "coder-hash": "coderWorkspace",
  "coder-url": "pairWorkspace",
  "coder-jwt": "pairWorkspace",
  "coder-kdf": "kdfWorkspace",
  "generator-uuid": "uuidWorkspace",
  "generator-useragent": "userAgentWorkspace",
  "generator-random": "randomWorkspace",
  "generator-totp": "totpWorkspace",
  "generator-sql": "dataWorkspace",
  "fingerprint-browser": "fingerprintWorkspace",
};

const coderMainTools = new Set(["coder-encode", "coder-decode", "coder-hash"]);
const pairTools = new Set(["converter-html-md", "coder-url", "coder-jwt"]);
const kdfTools = new Set(["coder-kdf"]);
const numberTools = new Set(["converter-number-bases"]);
const unitTools = new Set(["converter-units"]);
const timestampTools = new Set(["converter-timestamp"]);
const ipv4Tools = new Set(["converter-ipv4"]);
const generatorTools = new Set([
  "generator-uuid",
  "generator-useragent",
  "generator-random",
  "generator-totp",
  "generator-sql",
]);
const fingerprintTools = new Set(["fingerprint-browser"]);
const uuidToolSet = new Set(["generator-uuid"]);
const userAgentToolSet = new Set(["generator-useragent"]);
const randomToolSet = new Set(["generator-random"]);
const totpToolSet = new Set(["generator-totp"]);
const dataToolSet = new Set(["generator-sql"]);
const implementedTools = new Set([
  "format",
  "converter-html-md",
  "generator-uuid",
  "generator-useragent",
  "converter-number-bases",
  "converter-units",
  "converter-timestamp",
  "converter-ipv4",
  "coder-encode",
  "coder-decode",
  "coder-hash",
  "coder-url",
  "coder-jwt",
  "coder-kdf",
  "generator-random",
  "generator-totp",
  "generator-sql",
  "fingerprint-browser",
]);

const toolInfo = {};
toolGroups.forEach((group) => {
  group.tools.forEach((tool) => {
    toolInfo[tool.id] = {
      ...tool,
      workspace: workspaceByTool[tool.id] || "converterWorkspace",
    };
  });
});

const elements = {};
const workspaceIds = [
  "converterWorkspace",
  "coderWorkspace",
  "pairWorkspace",
  "numberWorkspace",
  "unitWorkspace",
  "timestampWorkspace",
  "ipv4Workspace",
  "kdfWorkspace",
  "uuidWorkspace",
  "userAgentWorkspace",
  "randomWorkspace",
  "totpWorkspace",
  "dataWorkspace",
  "fingerprintWorkspace",
];

const defaultDecoder = allEncodingVariants[0]?.key || "";

// Single source of truth for UI state/timers. Most handlers only mutate this
// object, then re-render the relevant panel.
const state = {
  currentTool: "format",
  wasmReady: false,
  uuidUppercase: false,
  currentUUIDs: {},
  currentBrowserFilter: "",
  currentOSFilter: "",
  currentUserAgents: [],
  coderMode: "encode",
  selectedDecoder: defaultDecoder,
  hashUppercase: false,
  hashEncoding: "base16",
  hashUseHmac: false,
  hashHmacSecret: "",
  lastEncodeResults: null,
  lastHashResults: null,
  encodeCaseMap: { base16: true, base32: true },
  currentPairTool: null,
  pairSyncing: false,
  pairLastSource: "input",
  urlQueryParams: [],
  urlBase: "",
  urlHash: "",
  urlHadQuestionMark: false,
  numberSyncing: false,
  unitSyncing: false,
  randomIncludeDigits: true,
  randomAllowLeadingZero: true,
  randomLength: 24,
  randomCount: 5,
  randomIncludeLower: false,
  randomIncludeUpper: false,
  randomExclude: "",
  randomMinDigits: 0,
  randomMinLower: 0,
  randomMinUpper: 0,
  randomMinSymbols: 0,
  randomSymbols: new Set(),
  randomResults: [],
  timestampUpdating: false,
  timestampActiveField: null,
  totpSecret: "",
  totpAlgorithm: "SHA256",
  totpPeriod: 30,
  totpDigits: 6,
  totpTimer: null,
  dataRows: 5,
  dataOverrides: {},
  dataTables: [],
  dataSchemaTimer: null,
  dataDirty: false,
  formatKey: null,
  fingerprintFacts: [],
  hashUppercase: false,
  hashEncoding: "base16",
  hashUseHmac: false,
  hashHmacSecret: "",
  kdf: {
    active: "bcrypt",
    bcryptCost: 10,
  argonTime: 3,
  argonMem: 65536,
  argonParallelism: 1,
  argonType: "argon2id",
  argonHashLen: 32,
    salts: {},
  },
};

let coderTimer = null;
let convertTimer = null;

const uuidDisplayOrder = [
  "v1",
  "v2",
  "v3",
  "v4",
  "v5",
  "v6",
  "v7",
  "v8",
  "guid",
  "ulid",
];
const uuidDisplayLabels = {
  guid: "GUID",
  ulid: "ULID",
};

boot();

async function boot() {
  cacheElements();
  renderSymbolButtons();
  initCoderControls();
  renderSidebar();
  bindUI();
  renderCoderEmpty();
  updateCoderTexts();
  selectTool(state.currentTool);
  setStatus("Loading WebAssembly...", false);
  try {
    await initWasm();
    state.wasmReady = true;
    setStatus("Ready", false);
    if (isUUIDTool(state.currentTool)) {
      refreshUUIDs(true);
    }
    if (isUserAgentTool(state.currentTool)) {
      refreshUserAgents(true);
    }
    if (
      isPairTool(state.currentTool) &&
      ((elements.pairInput && elements.pairInput.value.trim()) ||
        (elements.pairOutput && elements.pairOutput.value.trim()))
    ) {
      runPairConversion(state.pairLastSource);
    }
    if (isNumberTool(state.currentTool)) {
      const hasNumberValue = [
        elements.numberBinary,
        elements.numberOctal,
        elements.numberDecimal,
        elements.numberHex,
      ].some((input) => input && input.value.trim());
      if (hasNumberValue) {
        runNumberConversion("decimal");
      }
    }
    if (isIPv4Tool(state.currentTool) && elements.ipv4Input?.value.trim()) {
      runIPv4Conversion();
    }
    if (
      isTimestampTool(state.currentTool) &&
      elements.timestampInputs?.length
    ) {
      const filled = Array.from(elements.timestampInputs).find((input) =>
        input?.value?.trim(),
      );
      if (filled && filled.dataset.field) {
        runTimestampConversion(filled.dataset.field, filled.value, true);
      }
    }
    if (isTotpTool(state.currentTool)) {
      activateTotpTool();
    }
    if (isDataTool(state.currentTool)) {
      activateDataTool();
    }
  } catch (err) {
    console.error(err);
    setStatus(`Failed to load WebAssembly: ${err.message}`, true);
  }
}

function cacheElements() {
  elements.sidebar = document.getElementById("sidebar");
  elements.sidebarToggle = document.getElementById("sidebarToggle");
  elements.sidebarBackdrop = document.getElementById("sidebarBackdrop");
  elements.toolGroups = document.getElementById("toolGroups");
  elements.toolName = document.getElementById("toolName");
  elements.toolDesc = document.getElementById("toolDesc");
  elements.converterControls = document.getElementById("converterControls");
  elements.from = document.getElementById("fromSelect");
  elements.to = document.getElementById("toSelect");
  elements.swap = document.getElementById("swap");
  elements.input = document.getElementById("input");
  elements.output = document.getElementById("output");
  elements.copy = document.getElementById("copy");
  elements.clear = document.getElementById("clear");
  elements.formatInput = document.getElementById("formatInput");
  elements.minifyInput = document.getElementById("minifyInput");
  elements.formatOutput = document.getElementById("formatOutput");
  elements.minifyOutput = document.getElementById("minifyOutput");
  elements.status = document.getElementById("status");
  elements.coderWorkspace = document.getElementById("coderWorkspace");
  elements.coderInput = document.getElementById("coderInput");
  elements.coderResults = document.getElementById("coderResults");
  elements.coderWorkspaceTitle = document.getElementById("coderWorkspaceTitle");
  elements.coderModeHint = document.getElementById("coderModeHint");
  elements.decodeVariantWrap = document.getElementById("decodeVariantWrap");
  elements.decodeVariant = document.getElementById("decodeVariant");
  elements.coderResultActions = document.getElementById("coderResultActions");
  elements.hashToggleCase = document.getElementById("hashToggleCase");
  elements.hashEncoding = document.getElementById("hashEncoding");
  elements.hashControls = document.getElementById("hashControls");
  elements.hashUseHmac = document.getElementById("hashUseHmac");
  elements.hashHmacSecret = document.getElementById("hashHmacSecret");
  elements.coderResultHeading = document.getElementById("coderResultHeading");
  elements.coderResultHint = document.getElementById("coderResultHint");
  elements.pairWorkspace = document.getElementById("pairWorkspace");
  elements.pairInput = document.getElementById("pairInput");
  elements.pairOutput = document.getElementById("pairOutput");
  elements.pairInputLabel = document.getElementById("pairInputLabel");
  elements.pairOutputLabel = document.getElementById("pairOutputLabel");
  elements.pairInputHint = document.getElementById("pairInputHint");
  elements.pairOutputHint = document.getElementById("pairOutputHint");
  elements.jwtControls = document.getElementById("jwtControls");
  elements.jwtAlgorithm = document.getElementById("jwtAlgorithm");
  elements.jwtSecret = document.getElementById("jwtSecret");
  elements.pairOutputMeta = document.getElementById("pairOutputMeta");
  elements.urlQuerySection = document.getElementById("urlQuerySection");
  elements.urlQueryTable = document.getElementById("urlQueryTable");
  elements.urlQueryAdd = document.getElementById("urlQueryAdd");
  elements.urlQueryEmpty = document.getElementById("urlQueryEmpty");
  elements.kdfWorkspace = document.getElementById("kdfWorkspace");
  elements.kdfAlgoSelect = document.getElementById("kdfAlgoSelect");
  elements.kdfCards = document.querySelectorAll(".kdf-card");
  elements.kdfRefreshSalts = document.getElementById("kdfRefreshSalts");
  elements.bcryptPassword = document.getElementById("bcryptPassword");
  elements.bcryptCost = document.getElementById("bcryptCost");
  elements.bcryptSalt = document.getElementById("bcryptSalt");
  elements.bcryptOutput = document.getElementById("bcryptOutput");
  elements.bcryptVerifyHash = document.getElementById("bcryptVerifyHash");
  elements.bcryptHashBtn = document.getElementById("bcryptHashBtn");
  elements.bcryptVerifyBtn = document.getElementById("bcryptVerifyBtn");
  elements.bcryptStatus = document.getElementById("bcryptStatus");
  elements.argonPassword = document.getElementById("argonPassword");
  elements.argonSalt = document.getElementById("argonSalt");
  elements.argonTime = document.getElementById("argonTime");
  elements.argonMem = document.getElementById("argonMem");
  elements.argonParallelism = document.getElementById("argonParallelism");
  elements.argonType = document.getElementById("argonType");
  elements.argonHashLen = document.getElementById("argonHashLen");
  elements.argonOutput = document.getElementById("argonOutput");
  elements.argonVerifyHash = document.getElementById("argonVerifyHash");
  elements.argonHashBtn = document.getElementById("argonHashBtn");
  elements.argonVerifyBtn = document.getElementById("argonVerifyBtn");
  elements.argonStatus = document.getElementById("argonStatus");
  elements.numberWorkspace = document.getElementById("numberWorkspace");
  elements.numberBinary = document.getElementById("numberBinary");
  elements.numberOctal = document.getElementById("numberOctal");
  elements.numberDecimal = document.getElementById("numberDecimal");
  elements.numberHex = document.getElementById("numberHex");
  elements.unitWorkspace = document.getElementById("unitWorkspace");
  unitKeys.forEach((key) => {
    const id = `unit${capitalize(key)}`;
    elements[id] = document.getElementById(id);
  });
  elements.ipv4Workspace = document.getElementById("ipv4Workspace");
  elements.ipv4Input = document.getElementById("ipv4Input");
  elements.ipv4Results = document.getElementById("ipv4Results");
  elements.uuidList = document.getElementById("uuidList");
  elements.uuidToggleCase = document.getElementById("uuidToggleCase");
  elements.uuidRegenerate = document.getElementById("uuidRegenerate");
  elements.uaBrowser = document.getElementById("uaBrowser");
  elements.uaOS = document.getElementById("uaOS");
  elements.uaResults = document.getElementById("uaResults");
  elements.randomWorkspace = document.getElementById("randomWorkspace");
  elements.randomIncludeDigits = document.getElementById("randomIncludeDigits");
  elements.randomLength = document.getElementById("randomLength");
  elements.randomCount = document.getElementById("randomCount");
  elements.randomAllowZero = document.getElementById("randomAllowZero");
  elements.randomAllowZeroRow = document.getElementById("randomAllowZeroRow");
  elements.randomIncludeLower = document.getElementById("randomIncludeLower");
  elements.randomIncludeUpper = document.getElementById("randomIncludeUpper");
  elements.randomExclude = document.getElementById("randomExclude");
  elements.randomMinDigits = document.getElementById("randomMinDigits");
  elements.randomMinLower = document.getElementById("randomMinLower");
  elements.randomMinUpper = document.getElementById("randomMinUpper");
  elements.randomMinSymbols = document.getElementById("randomMinSymbols");
  elements.randomSymbolToggles = document.getElementById("randomSymbolToggles");
  elements.randomSymbolMinRow = document.getElementById("randomSymbolMinRow");
  elements.randomGenerate = document.getElementById("randomGenerate");
  elements.randomResults = document.getElementById("randomResults");
  elements.timestampInputs = document.querySelectorAll(
    "#timestampWorkspace input[data-field]",
  );
  elements.hashEncoding = document.getElementById("hashEncoding");
  elements.hashControls = document.getElementById("hashControls");
  elements.hashUseHmac = document.getElementById("hashUseHmac");
  elements.hashHmacSecret = document.getElementById("hashHmacSecret");
  elements.timestampPresets = document.getElementById("timestampPresets");
  elements.totpSecret = document.getElementById("totpSecret");
  elements.totpAlgorithm = document.getElementById("totpAlgorithm");
  elements.totpPeriod = document.getElementById("totpPeriod");
  elements.totpDigits = document.getElementById("totpDigits");
  elements.totpCode = document.getElementById("totpCode");
  elements.totpPeriodLabel = document.getElementById("totpPeriodLabel");
  elements.totpRemainingLabel = document.getElementById("totpRemainingLabel");
  elements.totpError = document.getElementById("totpError");
  elements.dataSchema = document.getElementById("dataSchema");
  elements.dataRows = document.getElementById("dataRows");
  elements.dataGenerate = document.getElementById("dataGenerate");
  elements.dataOutput = document.getElementById("dataOutput");
  elements.dataCopy = document.getElementById("dataCopy");
  elements.dataColumnEditor = document.getElementById("dataColumnEditor");
  elements.appShell = document.querySelector(".app-shell");
  elements.fingerprintGrid = document.getElementById("fingerprintGrid");
  elements.fingerprintSummary = document.getElementById("fingerprintSummary");
}

function renderSidebar() {
  if (!elements.toolGroups) return;
  elements.toolGroups.innerHTML = "";
  toolGroups.forEach((group) => {
    const details = document.createElement("details");
    details.open = true;
    const summary = document.createElement("summary");
    summary.textContent = group.name;
    details.appendChild(summary);
    const wrapper = document.createElement("div");
    wrapper.className = "tool-buttons";
    group.tools.forEach((tool) => {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.dataset.toolId = tool.id;
      btn.textContent = tool.label;
      btn.addEventListener("click", () => {
        selectTool(tool.id);
        closeSidebar();
      });
      wrapper.appendChild(btn);
    });
    details.appendChild(wrapper);
    elements.toolGroups.appendChild(details);
  });
  updateToolButtons();
}

function initCoderControls() {
  if (!elements.decodeVariant) return;
  const options = allEncodingVariants
    .map(
      (variant) =>
        `<option value="${variant.key}">${variant.group} · ${variant.label}</option>`,
    )
    .join("");
  elements.decodeVariant.innerHTML = options;
  if (!state.selectedDecoder && allEncodingVariants.length > 0) {
    state.selectedDecoder = allEncodingVariants[0].key;
  }
  if (state.selectedDecoder) {
    elements.decodeVariant.value = state.selectedDecoder;
  }
}

function bindUI() {
  elements.sidebarToggle?.addEventListener("click", toggleSidebar);
  elements.sidebarBackdrop?.addEventListener("click", closeSidebar);
  elements.swap?.addEventListener("click", () => {
    if (state.currentTool !== "format") return;
    const from = elements.from?.value || "";
    const to = elements.to?.value || "";
    if (elements.from) elements.from.value = to;
    if (elements.to) elements.to.value = from;
    if (elements.input && elements.output) {
      const previous = elements.input.value;
      elements.input.value = elements.output.value;
      elements.output.value = previous;
    }
    ensureConverterMode();
    scheduleConvert(true);
  });
  elements.copy?.addEventListener("click", () => {
    const value = elements.output?.value?.trim();
    if (!value) {
      setStatus("No output to copy", true);
      return;
    }
    copyText(value, "output");
  });
  elements.clear?.addEventListener("click", () => {
    if (elements.input) elements.input.value = "";
    if (elements.output) elements.output.value = "";
    setStatus("Cleared input/output", false);
  });
  elements.from?.addEventListener("change", () => {
    ensureConverterMode();
    scheduleConvert(true);
  });
  elements.to?.addEventListener("change", () => {
    ensureConverterMode();
    scheduleConvert(true);
  });
  elements.input?.addEventListener("input", () => scheduleConvert());
  elements.formatInput?.addEventListener("click", () =>
    handleFormatField(elements.input, elements.from?.value, false),
  );
  elements.minifyInput?.addEventListener("click", () =>
    handleFormatField(elements.input, elements.from?.value, true),
  );
  elements.formatOutput?.addEventListener("click", () =>
    handleFormatField(elements.output, elements.to?.value, false),
  );
  elements.minifyOutput?.addEventListener("click", () =>
    handleFormatField(elements.output, elements.to?.value, true),
  );
  elements.coderInput?.addEventListener("input", () => scheduleCoder());
  elements.decodeVariant?.addEventListener("change", (event) => {
    state.selectedDecoder = event.target.value;
    updateCoderTexts();
    scheduleCoder(true);
  });
  elements.hashToggleCase?.addEventListener("click", () => {
    state.hashUppercase = !state.hashUppercase;
    elements.hashToggleCase.dataset.upper = state.hashUppercase
      ? "true"
      : "false";
    if (state.lastHashResults) {
      renderHashResults(state.lastHashResults);
    }
  });
  elements.coderResults?.addEventListener("click", (event) => {
    const toggle = event.target.closest("button[data-encode-group]");
    if (toggle) {
      const group = toggle.dataset.encodeGroup || "";
      if (group) {
        state.encodeCaseMap[group] = !state.encodeCaseMap[group];
        if (state.lastEncodeResults) {
          renderEncodeResults(state.lastEncodeResults);
        }
      }
      return;
    }
    const button = event.target.closest("button[data-value]");
    if (button) {
      const value = button.dataset.value || "";
      if (value) {
        copyText(value, button.dataset.label || "Result");
      }
      return;
    }
    const entry = event.target.closest(".coder-entry[data-copy-value]");
    if (entry) {
      const value = entry.dataset.copyValue || "";
      if (value) {
        copyText(value, entry.dataset.copyLabel || "Result");
      }
    }
  });
  elements.pairInput?.addEventListener("input", () => handlePairInput("input"));
  elements.pairOutput?.addEventListener("input", () =>
    handlePairInput("output"),
  );
  elements.urlQueryTable?.addEventListener("input", handleUrlQueryTableInput);
  elements.urlQueryTable?.addEventListener("click", handleUrlQueryTableClick);
  elements.urlQueryAdd?.addEventListener("click", () => addUrlQueryRow());
  elements.hashToggleCase?.addEventListener("click", () => {
    state.hashUppercase = !state.hashUppercase;
    elements.hashToggleCase.dataset.upper = state.hashUppercase
      ? "true"
      : "false";
    if (state.lastHashResults) {
      renderHashResults(state.lastHashResults);
    }
  });
  elements.hashEncoding?.addEventListener("change", handleHashEncodingChange);
  elements.hashUseHmac?.addEventListener("change", handleHashModeToggle);
  elements.hashHmacSecret?.addEventListener("input", handleHashSecretInput);
  elements.jwtAlgorithm?.addEventListener("change", () => {
    if (state.currentTool === "coder-jwt") {
      runPairConversion("input");
    }
  });
  elements.jwtSecret?.addEventListener("input", () => {
    if (
      state.currentTool === "coder-jwt" &&
      state.pairLastSource === "input" &&
      elements.pairInput?.value.trim()
    ) {
      runPairConversion("input");
    }
  });
  elements.numberBinary?.addEventListener("input", () =>
    handleNumberInput("binary"),
  );
  elements.numberOctal?.addEventListener("input", () =>
    handleNumberInput("octal"),
  );
  elements.numberDecimal?.addEventListener("input", () =>
    handleNumberInput("decimal"),
  );
  elements.numberHex?.addEventListener("input", () => handleNumberInput("hex"));
  unitKeys.forEach((key) => {
    const id = `unit${capitalize(key)}`;
    elements[id]?.addEventListener("input", () => handleUnitInput(key));
  });
  elements.ipv4Input?.addEventListener("input", () => runIPv4Conversion());
  elements.ipv4Results?.addEventListener("click", (event) => {
    const target = event.target.closest("[data-copy-value]");
    if (target) {
      const toCopy = target.dataset.copyValue || "";
      if (toCopy) {
        copyText(toCopy, "IP value");
        setStatus("Copied", false);
      }
    }
  });
  elements.uuidToggleCase?.addEventListener("click", () => {
    state.uuidUppercase = !state.uuidUppercase;
    if (elements.uuidToggleCase) {
      elements.uuidToggleCase.dataset.upper = state.uuidUppercase
        ? "true"
        : "false";
    }
    renderUUIDs();
  });
  elements.uuidRegenerate?.addEventListener("click", () => refreshUUIDs(true));
  elements.uaBrowser?.addEventListener("change", () => refreshUserAgents(true));
  elements.uaOS?.addEventListener("change", () => refreshUserAgents(true));
  elements.randomIncludeDigits?.addEventListener(
    "change",
    handleRandomIncludeDigitsChange,
  );
  elements.randomLength?.addEventListener("input", handleRandomLengthChange);
  elements.randomCount?.addEventListener("input", handleRandomCountChange);
  elements.randomAllowZero?.addEventListener(
    "change",
    handleRandomLeadingToggle,
  );
  elements.randomIncludeLower?.addEventListener(
    "change",
    handleRandomIncludeLowerChange,
  );
  elements.randomIncludeUpper?.addEventListener(
    "change",
    handleRandomIncludeUpperChange,
  );
  elements.randomExclude?.addEventListener("input", handleRandomExcludeInput);
  elements.randomMinDigits?.addEventListener("input", () =>
    handleRandomMinChange("digits"),
  );
  elements.randomMinLower?.addEventListener("input", () =>
    handleRandomMinChange("lower"),
  );
  elements.randomMinUpper?.addEventListener("input", () =>
    handleRandomMinChange("upper"),
  );
  elements.randomMinSymbols?.addEventListener("input", () =>
    handleRandomMinChange("symbols"),
  );
  elements.randomSymbolToggles?.addEventListener(
    "click",
    handleRandomSymbolToggle,
  );
  elements.randomGenerate?.addEventListener("click", () =>
    runRandomGenerator(),
  );
  elements.randomResults?.addEventListener("click", handleRandomResultsClick);
  elements.kdfAlgoSelect = document.getElementById("kdfAlgoSelect");
  elements.kdfCards = document.querySelectorAll(".kdf-card");
  elements.kdfAlgoSelect?.addEventListener("change", (ev) => {
    setKdfAlgorithm(ev.target.value);
  });
  elements.kdfRefreshSalts?.addEventListener("click", refreshKdfSalts);
  elements.bcryptHashBtn?.addEventListener("click", (ev) => {
    ev.preventDefault();
    runBcryptHash();
  });
  elements.bcryptVerifyBtn?.addEventListener("click", (ev) => {
    ev.preventDefault();
    verifyBcrypt();
  });
  elements.argonHashBtn?.addEventListener("click", (ev) => {
    ev.preventDefault();
    runArgonHash();
  });
  elements.argonVerifyBtn?.addEventListener("click", (ev) => {
    ev.preventDefault();
    verifyArgon();
  });
  elements.hashEncoding?.addEventListener("change", handleHashEncodingChange);
  elements.hashUseHmac?.addEventListener("change", handleHashModeToggle);
  elements.hashHmacSecret?.addEventListener("input", handleHashSecretInput);
  elements.timestampInputs?.forEach((input) =>
    input.addEventListener("input", handleTimestampInput),
  );
  elements.timestampPresets?.addEventListener("click", handleTimestampPreset);
  elements.totpSecret?.addEventListener("input", handleTotpFieldChange);
  elements.totpAlgorithm?.addEventListener("change", handleTotpFieldChange);
  elements.totpPeriod?.addEventListener("input", handleTotpFieldChange);
  elements.totpDigits?.addEventListener("input", handleTotpFieldChange);
  elements.totpCode?.addEventListener("click", copyTotpCode);
  elements.dataSchema?.addEventListener("input", handleDataSchemaInput);
  elements.dataRows?.addEventListener("input", handleDataRowsChange);
  elements.dataGenerate?.addEventListener("click", () => runDataGenerator());
  elements.dataCopy?.addEventListener("click", copyDataOutput);
  elements.dataColumnEditor?.addEventListener("input", handleDataOverrideInput);
}

function toggleSidebar() {
  document.body.classList.toggle("sidebar-open");
}

function closeSidebar() {
  document.body.classList.remove("sidebar-open");
}

function closeSidebarOnMobile() {
  if (window.matchMedia("(max-width: 900px)").matches) {
    closeSidebar();
  }
}

window.addEventListener("resize", () => {
  if (window.innerWidth > 900) {
    closeSidebar();
  }
});

function ensureConverterMode() {
  if (state.currentTool !== "format") return false;
  const from = elements.from?.value || "";
  const to = elements.to?.value || "";
  if (!supportedFormats.has(from) || !supportedFormats.has(to)) {
    setStatus("Unsupported format", true);
    return false;
  }
  if (elements.inputLabel) elements.inputLabel.textContent = from;
  if (elements.outputLabel) elements.outputLabel.textContent = to;
  if (elements.input) {
    elements.input.placeholder = samples[from] || "";
  }
  state.formatKey = `${from}|${to}`;
  return true;
}

function scheduleConvert(immediate = false) {
  if (state.currentTool !== "format") return;
  if (!ensureConverterMode()) return;
  if (immediate) {
    convert();
    return;
  }
  clearTimeout(convertTimer);
  convertTimer = setTimeout(() => convert(), 250);
}

function convert() {
  if (state.currentTool !== "format") return;
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
    return;
  }
  const from = elements.from?.value || "";
  const to = elements.to?.value || "";
  const text = elements.input?.value || "";
  if (!text.trim()) {
    if (elements.output) elements.output.value = "";
    setStatus("Input is empty");
    return;
  }
  try {
    const result = transform_format(from, to, text);
    if (elements.output) {
      elements.output.value = result || "";
    }
    setStatus("Done", false);
  } catch (err) {
    if (elements.output) elements.output.value = "";
    setStatus(`⚠️ ${err?.message || err}`, true);
  }
}

function handleFormatField(target, formatName, minify) {
  if (!target || state.currentTool !== "format") return;
  if (!formatName || !supportedFormats.has(formatName)) {
    setStatus("Unsupported format", true);
    return;
  }
  if (!target.value.trim()) {
    setStatus("Nothing to process", true);
    return;
  }
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
    return;
  }
  try {
    const updated = format_content_text(
      formatName,
      target.value,
      Boolean(minify),
    );
    target.value = updated || "";
    setStatus(minify ? "Minified" : "Formatted", false);
  } catch (err) {
    setStatus(`⚠️ ${err?.message || err}`, true);
  }
}

function selectTool(toolId) {
  const meta = toolInfo[toolId];
  if (!meta) return;
  const previousTool = state.currentTool;
  state.currentTool = toolId;
  elements.toolName && (elements.toolName.textContent = meta.label);
  elements.toolDesc && (elements.toolDesc.textContent = meta.description || "");
  updateBodyClasses(toolId);
  const workspaceId = meta.workspace;
  showWorkspace(workspaceId);
  toggleConverterControls(toolId === "format");
  updateToolButtons();
  closeSidebarOnMobile();
  if (previousTool && isTotpTool(previousTool) && !isTotpTool(toolId)) {
    stopTotpTimer();
  }
  if (!implementedTools.has(toolId)) {
    setStatus("This tool isn't wired up in this build.", true);
  } else {
    setStatus("Ready", false);
  }
  if (toolId === "format") {
    ensureConverterMode();
    scheduleConvert(true);
    return;
  }
  if (coderMainTools.has(toolId)) {
    const nextMode = coderToolModes[toolId] || "encode";
    const changed = state.coderMode !== nextMode;
    state.coderMode = nextMode;
    updateCoderTexts();
    if (changed) {
      renderCoderEmpty();
    }
    scheduleCoder(true);
    return;
  }
  if (isPairTool(toolId)) {
    activatePairTool(toolId);
    return;
  }
  if (isKdfTool(toolId)) {
    activateKdfTool();
    return;
  }
  if (isNumberTool(toolId)) {
    activateNumberTool();
    return;
  }
  if (isUnitTool(toolId)) {
    activateUnitTool();
    return;
  }
  if (isTimestampTool(toolId)) {
    activateTimestampTool();
    return;
  }
  if (isIPv4Tool(toolId)) {
    activateIPv4Tool();
    return;
  }
  if (isUUIDTool(toolId)) {
    activateUUIDTool();
  } else if (isUserAgentTool(toolId)) {
    activateUserAgentTool();
  } else if (isRandomTool(toolId)) {
    activateRandomTool();
  } else if (isTotpTool(toolId)) {
    activateTotpTool();
  } else if (isDataTool(toolId)) {
    activateDataTool();
  } else if (isFingerprintTool(toolId)) {
    activateFingerprintTool();
  }
}

function updateBodyClasses(toolId) {
  document.body.classList.toggle("tool-format", toolId === "format");
  document.body.classList.toggle("tool-coder", coderMainTools.has(toolId));
  document.body.classList.toggle("tool-pair", pairTools.has(toolId));
  document.body.classList.toggle("tool-kdf", isKdfTool(toolId));
  document.body.classList.toggle("tool-number", numberTools.has(toolId));
  document.body.classList.toggle("tool-unit", unitTools.has(toolId));
  document.body.classList.toggle("tool-ipv4", ipv4Tools.has(toolId));
  document.body.classList.toggle("tool-generator", generatorTools.has(toolId));
  document.body.classList.toggle("tool-fingerprint", isFingerprintTool(toolId));
  document.body.classList.toggle("tool-uuid", isUUIDTool(toolId));
  document.body.classList.toggle("tool-useragent", isUserAgentTool(toolId));
  document.body.classList.toggle("tool-random", isRandomTool(toolId));
}

function toggleConverterControls(show) {
  if (elements.converterControls) {
    elements.converterControls.classList.toggle("hidden", !show);
  }
}

function showWorkspace(workspaceId) {
  workspaceIds.forEach((id) => {
    const el = document.getElementById(id);
    if (el) {
      el.classList.toggle("hidden", id !== workspaceId);
    }
  });
}

function updateToolButtons() {
  document
    .querySelectorAll("#toolGroups button")
    .forEach((btn) =>
      btn.classList.toggle("active", btn.dataset.toolId === state.currentTool),
    );
}

function setStatus(message, isError) {
  if (!elements.status) return;
  elements.status.textContent = message || "Ready";
  elements.status.classList.toggle("error", Boolean(isError));
}

function scheduleCoder(immediate = false) {
  if (!coderMainTools.has(state.currentTool)) return;
  if (immediate) {
    runCoder();
    return;
  }
  clearTimeout(coderTimer);
  coderTimer = setTimeout(() => runCoder(), 200);
}

function runCoder() {
  if (!coderMainTools.has(state.currentTool)) return;
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
    return;
  }
  const text = elements.coderInput?.value || "";
  const trimmed = text.trim();
  if (!trimmed && state.coderMode !== "hash") {
    renderCoderEmpty();
    return;
  }
  try {
    if (state.coderMode === "encode") {
      const result = encode_content(text);
      const map = normalizeMapResult(result);
      state.lastEncodeResults = map;
      renderEncodeResults(map);
      setStatus("Done", false);
      return;
    }
    if (state.coderMode === "decode") {
      const decoderKey =
        state.selectedDecoder || elements.decodeVariant?.value || "";
      if (!decoderKey) {
        setStatus("Select an encoding to decode", true);
        return;
      }
      const decodeInput =
        decoderKey === "hex_upper" ? text.toUpperCase() : text;
      const decoded = decode_content(decoderKey, decodeInput);
      const info = encodingVariantMap.get(decoderKey);
      const displayLabel = info ? `${info.group} · ${info.label}` : "Decoded";
      renderDecodeResult(decoded, displayLabel);
      setStatus("Done", false);
      return;
    }
    const hashes = state.hashUseHmac
      ? hash_content_hmac(text, state.hashHmacSecret || "")
      : hash_content(text);
    const map = normalizeMapResult(hashes);
    state.lastHashResults = map;
    renderHashResults(map);
    setStatus("Done", false);
  } catch (err) {
    renderCoderEmpty();
    setStatus(`⚠️ ${err?.message || err}`, true);
  }
}

function updateCoderTexts() {
  if (elements.coderWorkspaceTitle) {
    elements.coderWorkspaceTitle.textContent =
      coderModeTitles[state.coderMode] || state.coderMode;
  }
  if (elements.coderModeHint) {
    elements.coderModeHint.textContent =
      coderModeDescriptions[state.coderMode] || "";
  }
  if (elements.coderResultHeading) {
    const heading =
      state.coderMode === "hash"
        ? "Hash Digests"
        : state.coderMode === "decode"
          ? "Decode"
          : "Encodings";
    elements.coderResultHeading.textContent = heading;
  }
  if (elements.coderResultHint) {
    if (state.coderMode === "decode") {
      const info = encodingVariantMap.get(state.selectedDecoder);
      elements.coderResultHint.textContent = info
        ? `${info.group} · ${info.label}`
        : coderResultHints.decode;
    } else {
      elements.coderResultHint.textContent =
        coderResultHints[state.coderMode] || "";
    }
  }
  if (elements.decodeVariantWrap) {
    elements.decodeVariantWrap.classList.toggle(
      "hidden",
      state.coderMode !== "decode",
    );
  }
  if (elements.decodeVariant && state.selectedDecoder) {
    elements.decodeVariant.value = state.selectedDecoder;
  }
  if (elements.hashToggleCase) {
    const showToggle = state.coderMode === "hash";
    elements.hashToggleCase.classList.toggle("hidden", !showToggle);
    if (showToggle) {
      elements.hashToggleCase.dataset.upper = state.hashUppercase
        ? "true"
        : "false";
    }
  }
  if (elements.hashControls) {
    const show = state.coderMode === "hash";
    elements.hashControls.classList.toggle("hidden", !show);
    if (show) {
      if (elements.hashEncoding) elements.hashEncoding.value = state.hashEncoding;
      if (elements.hashUseHmac) elements.hashUseHmac.checked = state.hashUseHmac;
      if (elements.hashHmacSecret) {
        elements.hashHmacSecret.classList.toggle("hidden", !state.hashUseHmac);
        elements.hashHmacSecret.value = state.hashHmacSecret;
      }
    }
  }
  if (elements.coderInput) {
    elements.coderInput.placeholder =
      coderPlaceholders[state.coderMode] || coderPlaceholders.encode;
  }
  updateCoderActionsVisibility();
}

function renderCoderEmpty() {
  if (!elements.coderResults) return;
  if (state.coderMode === "hash") {
    state.lastHashResults = null;
  }
  if (state.coderMode === "encode") {
    state.lastEncodeResults = null;
  }
  const message =
    state.coderMode === "decode"
      ? "Paste encoded text to decode"
      : "Enter content to see results";
  elements.coderResults.innerHTML = `<div class="muted">${message}</div>`;
}

function updateCoderActionsVisibility() {
  if (!elements.coderResultActions) return;
  const show = state.coderMode === "hash";
  elements.coderResultActions.classList.toggle("hidden", !show);
  if (elements.hashToggleCase) {
    elements.hashToggleCase.classList.toggle("hidden", !show);
  }
}

function encodeDigest(hexValue) {
  const lower = state.hashUppercase ? hexValue.toUpperCase() : hexValue.toLowerCase();
  if (state.hashEncoding === "base16") return lower;
  const bytes = hexToUint8(lower);
  if (!bytes) return lower;
  if (state.hashEncoding === "base64") {
    return toBase64(bytes, false);
  }
  if (state.hashEncoding === "base64_raw") {
    return toBase64(bytes, true);
  }
  if (state.hashEncoding === "base64_url") {
    return toBase64(bytes, false).replace(/\+/g, "-").replace(/\//g, "_");
  }
  if (state.hashEncoding === "base64_url_raw") {
    return toBase64(bytes, true).replace(/\+/g, "-").replace(/\//g, "_");
  }
  return lower;
}

function hexToUint8(hex) {
  if (!hex || hex.length % 2 !== 0) return null;
  const arr = new Uint8Array(hex.length / 2);
  for (let i = 0; i < arr.length; i++) {
    const byte = Number.parseInt(hex.substr(i * 2, 2), 16);
    if (Number.isNaN(byte)) return null;
    arr[i] = byte;
  }
  return arr;
}

function toBase64(bytes, stripPadding) {
  let binary = "";
  bytes.forEach((b) => {
    binary += String.fromCharCode(b);
  });
  const encoded = btoa(binary);
  return stripPadding ? encoded.replace(/=+$/, "") : encoded;
}

function renderEncodeResults(map) {
  if (!elements.coderResults) return;
  const blocks = encodingGroups
    .map((group) => {
      let toggleInjected = false;
      const entries = group.variants
        .map((variant) => {
          const raw = map?.[variant.key];
          if (typeof raw !== "string") {
            return null;
          }
          let displayValue = raw;
          let toggleGroup = null;
          if (group.id === "base16") {
            const upper = state.encodeCaseMap.base16 !== false;
            displayValue = upper ? raw.toUpperCase() : raw.toLowerCase();
            if (!toggleInjected) {
              toggleGroup = "base16";
              toggleInjected = true;
            }
          } else if (group.id === "base32") {
            const upper = state.encodeCaseMap.base32 !== false;
            displayValue = upper ? raw.toUpperCase() : raw.toLowerCase();
            if (!toggleInjected) {
              toggleGroup = "base32";
              toggleInjected = true;
            }
          }
          return {
            label: variant.label,
            value: displayValue,
            copyLabel: `${group.label} · ${variant.label}`,
            clickCopy: true,
            toggleGroup,
          };
        })
        .filter(Boolean);
      if (!entries.length) {
        return "";
      }
      return renderGroupBlock(group.label, entries);
    })
    .filter(Boolean);
  if (!blocks.length) {
    renderCoderEmpty();
    return;
  }
  elements.coderResults.innerHTML = `
    <div class="coder-groups">
      <div class="coder-output-grid">${blocks.join("")}</div>
    </div>
  `;
}

function renderDecodeResult(value, label) {
  if (!elements.coderResults) return;
  const block = renderGroupBlock(label || "Decoded", [
    {
      label: label || "Decoded",
      value: value || "",
      copyLabel: label || "Decoded",
    },
  ]);
  elements.coderResults.innerHTML = `
    <div class="coder-groups">
      <div class="coder-output-grid">${block}</div>
    </div>
  `;
}

function renderHashResults(map) {
  if (!elements.coderResults) return;
  const blocks = hashGroups
    .map((group) => {
      const entries = group.keys
        .map((key) => {
          const raw = map?.[key];
          if (typeof raw !== "string") {
            return null;
          }
          const label = hashLabels[key] || key;
          const value = encodeDigest(raw);
          return {
            label,
            value,
            copyLabel: label,
            clickCopy: true,
          };
        })
        .filter(Boolean);
      if (!entries.length) return "";
      return renderGroupBlock(group.label, entries);
    })
    .filter(Boolean);
  if (!blocks.length) {
    renderCoderEmpty();
    return;
  }
  elements.coderResults.innerHTML = `
    <div class="coder-groups">
      <div class="coder-output-grid">${blocks.join("")}</div>
    </div>
  `;
}

function renderGroupBlock(title, entries) {
  if (!entries.length) return "";
  const rows = entries.map((entry) => renderEntryRow(entry)).join("");
  const safeTitle = escapeHTML(title || "Result");
  return `
    <section class="coder-output-block">
      <header>${safeTitle}</header>
      <div class="coder-output-entries">
        ${rows}
      </div>
    </section>
  `;
}

function renderEntryRow(entry) {
  const clickable = !!entry.clickCopy;
  const safeLabel = escapeHTML(entry.label || "Result");
  const safeValue = escapeHTML(entry.value || "");
  const attrValue = escapeAttr(entry.value || "");
  const buttonLabel = escapeAttr(entry.copyLabel || entry.label || "Result");
  const entryAttrs = clickable
    ? `class="coder-entry click-copy" data-copy-value="${attrValue}" data-copy-label="${buttonLabel}"`
    : `class="coder-entry"`;
  const toggleGroup = entry.toggleGroup || null;
  let actionMarkup = "";
  if (toggleGroup) {
    const upperActive = state.encodeCaseMap[toggleGroup] !== false;
    actionMarkup = `<button type="button" data-encode-group="${toggleGroup}" data-upper="${upperActive ? "true" : "false"}">Toggle Case</button>`;
  } else if (clickable) {
    actionMarkup = '<span class="copy-hint">Click to copy</span>';
  } else {
    actionMarkup = `<button type="button" data-label="${buttonLabel}" data-value="${attrValue}">Copy</button>`;
  }
  return `
    <div ${entryAttrs}>
      <div class="coder-entry-meta">
        <span>${safeLabel}</span>
        ${actionMarkup}
      </div>
      <textarea readonly spellcheck="false">${safeValue}</textarea>
    </div>
  `;
}

function isUUIDTool(toolId) {
  return uuidToolSet.has(toolId);
}

function isUserAgentTool(toolId) {
  return userAgentToolSet.has(toolId);
}

function isPairTool(toolId) {
  return pairTools.has(toolId);
}

function isKdfTool(toolId) {
  return kdfTools.has(toolId);
}

function isNumberTool(toolId) {
  return numberTools.has(toolId);
}

function isUnitTool(toolId) {
  return unitTools.has(toolId);
}

function isUrlTool(toolId) {
  return toolId === "coder-url";
}

function isTimestampTool(toolId) {
  return timestampTools.has(toolId);
}

function isIPv4Tool(toolId) {
  return ipv4Tools.has(toolId);
}

function isRandomTool(toolId) {
  return randomToolSet.has(toolId);
}

function isTotpTool(toolId) {
  return totpToolSet.has(toolId);
}

function isDataTool(toolId) {
  return dataToolSet.has(toolId);
}

function isFingerprintTool(toolId) {
  return fingerprintTools.has(toolId);
}

function activatePairTool(toolId) {
  state.currentPairTool = toolId;
  state.pairLastSource = "input";
  const config = pairToolConfigs[toolId];
  if (!config) {
    setStatus("This tool isn't wired up in this build.", true);
    return;
  }
  if (elements.pairInputLabel) {
    elements.pairInputLabel.textContent = config.inputLabel || "Encode";
  }
  if (elements.pairOutputLabel) {
    elements.pairOutputLabel.textContent = config.outputLabel || "Decode";
  }
  if (elements.pairInputHint) {
    elements.pairInputHint.textContent = config.inputHint || "";
  }
  if (elements.pairOutputHint) {
    elements.pairOutputHint.textContent = config.outputHint || "";
  }
  if (elements.pairInput) {
    elements.pairInput.placeholder = config.inputPlaceholder || "";
    elements.pairInput.value = "";
  }
  if (elements.pairOutput) {
    elements.pairOutput.placeholder = config.outputPlaceholder || "";
    elements.pairOutput.value = "";
  }
  const showJWT = config.type === "jwt";
  elements.jwtControls?.classList.toggle("hidden", !showJWT);
  if (!showJWT) {
    if (elements.jwtSecret) {
      elements.jwtSecret.value = "";
    }
    updatePairMeta(null);
  } else if (elements.jwtAlgorithm && !elements.jwtAlgorithm.value) {
    elements.jwtAlgorithm.value = "HS256";
  }
  const showQueryEditor = config.type === "url";
  elements.urlQuerySection?.classList.toggle("hidden", !showQueryEditor);
  if (showQueryEditor) {
    syncUrlParamsFromInput(elements.pairInput?.value || "", true);
  } else {
    resetUrlQueryState();
  }
  updatePairMeta(null);
  setStatus("Ready", false);
}

function handlePairInput(source) {
  if (!isPairTool(state.currentTool) || state.pairSyncing) return;
  runPairConversion(source);
}

function runPairConversion(source) {
  if (!isPairTool(state.currentTool)) return;
  const config = pairToolConfigs[state.currentTool];
  if (!config) {
    setStatus("This tool isn't wired up in this build.", true);
    return;
  }
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
    return;
  }
  state.pairLastSource = source;
  const inputValue = elements.pairInput?.value || "";
  const outputValue = elements.pairOutput?.value || "";
  if (config.type === "url") {
    if (source === "input") {
      syncUrlParamsFromInput(inputValue, true);
      renderUrlEncodeOutput(inputValue);
      return;
    }
    if (!outputValue) {
      setPairField(elements.pairInput, "");
      resetUrlQueryState();
      setStatus("Cleared");
      return;
    }
    try {
      const decoded = url_decode(outputValue);
      setPairField(elements.pairInput, decoded);
      syncUrlParamsFromInput(decoded, true);
      setStatus("Done", false);
    } catch (err) {
      setStatus(`⚠️ ${err?.message || err}`, true);
    }
    return;
  }
  if (config.type === "jwt") {
    if (source === "input") {
      if (!inputValue.trim()) {
        setPairField(elements.pairOutput, "");
        updatePairMeta(null);
        setStatus("Cleared");
        return;
      }
      const secret = elements.jwtSecret?.value || "";
      if (!secret.trim()) {
        setStatus("Secret is required", true);
        return;
      }
      const algorithm = elements.jwtAlgorithm?.value || "HS256";
      try {
        const token = jwt_encode(inputValue, secret, algorithm);
        setPairField(elements.pairOutput, token);
        updatePairMeta(null);
        setStatus("Done", false);
      } catch (err) {
        setStatus(`⚠️ ${err?.message || err}`, true);
      }
      return;
    }
    if (!outputValue.trim()) {
      setPairField(elements.pairInput, "");
      updatePairMeta(null);
      setStatus("Cleared");
      return;
    }
    try {
      const info = jwt_decode(outputValue) || {};
      if (info.payload && elements.pairInput) {
        setPairField(elements.pairInput, info.payload);
      }
      if (info.algorithm && elements.jwtAlgorithm) {
        elements.jwtAlgorithm.value = info.algorithm;
      }
      updatePairMeta(info);
      setStatus("Done", false);
    } catch (err) {
      setStatus(`⚠️ ${err?.message || err}`, true);
    }
    return;
  }
  if (config.type === "markdown") {
    if (source === "input") {
      if (!inputValue.trim()) {
        setPairField(elements.pairOutput, "");
        setStatus("Cleared");
        return;
      }
      try {
        const html = markdown_to_html_text(inputValue);
        setPairField(elements.pairOutput, html || "");
        setStatus("Done", false);
      } catch (err) {
        setStatus(`⚠️ ${err?.message || err}`, true);
      }
      return;
    }
    if (!outputValue.trim()) {
      setPairField(elements.pairInput, "");
      setStatus("Cleared");
      return;
    }
    try {
      const markdown = html_to_markdown_text(outputValue);
      setPairField(elements.pairInput, markdown || "");
      setStatus("Done", false);
    } catch (err) {
      setStatus(`⚠️ ${err?.message || err}`, true);
    }
    return;
  }
  setStatus("This tool isn't wired up in this build.", true);
}

// Query editor helpers keep the URL Encode textarea, table, and encoded output aligned.
function syncUrlParamsFromInput(rawInput, renderTable = false) {
  if (!isUrlTool(state.currentTool)) return;
  const parts = splitUrlParts(rawInput || "");
  state.urlBase = parts.base;
  state.urlHash = parts.hash;
  state.urlHadQuestionMark = parts.hadQuestionMark;
  state.urlQueryParams = parseQueryParams(parts.queryString);
  if (renderTable) {
    renderUrlQueryTable();
  }
}

function resetUrlQueryState() {
  state.urlQueryParams = [];
  state.urlBase = "";
  state.urlHash = "";
  state.urlHadQuestionMark = false;
  if (isUrlTool(state.currentTool)) {
    renderUrlQueryTable();
  }
}

function splitUrlParts(raw) {
  const text = raw || "";
  const hashIndex = text.indexOf("#");
  const beforeHash = hashIndex >= 0 ? text.slice(0, hashIndex) : text;
  const hash = hashIndex >= 0 ? text.slice(hashIndex + 1) : "";
  const qmIndex = beforeHash.indexOf("?");
  const base = qmIndex >= 0 ? beforeHash.slice(0, qmIndex) : beforeHash;
  const queryString = qmIndex >= 0 ? beforeHash.slice(qmIndex + 1) : "";
  return {
    base,
    queryString,
    hash,
    hadQuestionMark: qmIndex >= 0,
  };
}

function parseQueryParams(queryString) {
  if (!queryString) return [];
  return queryString
    .split("&")
    .filter((entry) => entry.length > 0)
    .map((entry) => {
      const [rawKey, ...rest] = entry.split("=");
      const rawValue = rest.length ? rest.join("=") : "";
      return {
        key: decodeQueryPiece(rawKey),
        value: decodeQueryPiece(rawValue),
      };
    });
}

function decodeQueryPiece(text) {
  if (!text) return "";
  const normalized = text.replace(/\+/g, " ");
  try {
    return decodeURIComponent(normalized);
  } catch (err) {
    return normalized;
  }
}

function serializeQueryParams(params) {
  if (!params?.length) return "";
  const filtered = params.filter(
    (entry) => (entry?.key || entry?.value || "").length > 0,
  );
  if (!filtered.length) return "";
  return filtered.map(({ key, value }) => `${key || ""}=${value || ""}`).join("&");
}

function buildUrlFromState() {
  const query = serializeQueryParams(state.urlQueryParams);
  const hasParams = Boolean(query);
  const hasHash = Boolean(state.urlHash);
  let url = state.urlBase || "";
  if (hasParams || state.urlHadQuestionMark) {
    url += "?" + query;
  }
  if (hasHash) {
    url += "#" + state.urlHash;
  }
  return url;
}

function renderUrlEncodeOutput(rawInput) {
  state.pairLastSource = "input";
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
    return;
  }
  if (!rawInput) {
    setPairField(elements.pairOutput, "");
    setStatus("Cleared");
    return;
  }
  try {
    const encoded = url_encode(rawInput);
    setPairField(elements.pairOutput, encoded);
    setStatus("Done", false);
  } catch (err) {
    setStatus(`⚠️ ${err?.message || err}`, true);
  }
}

function applyUrlQueryStateChange({ renderTable = false } = {}) {
  const rebuilt = buildUrlFromState();
  setPairField(elements.pairInput, rebuilt);
  renderUrlEncodeOutput(rebuilt);
  if (renderTable) {
    renderUrlQueryTable();
  }
}

function renderUrlQueryTable() {
  if (!elements.urlQueryTable) return;
  const params = state.urlQueryParams || [];
  elements.urlQueryTable.innerHTML = "";
  if (!params.length) {
    if (elements.urlQueryEmpty) elements.urlQueryEmpty.classList.remove("hidden");
    return;
  }
  if (elements.urlQueryEmpty) elements.urlQueryEmpty.classList.add("hidden");
  params.forEach((param, index) => {
    const row = document.createElement("div");
    row.className = "query-row";
    row.dataset.index = String(index);

    const handle = document.createElement("span");
    handle.className = "query-handle";
    handle.title = "Reorder";
    handle.textContent = "≡";
    row.appendChild(handle);

    const keyInput = document.createElement("input");
    keyInput.placeholder = "key";
    keyInput.value = param?.key || "";
    keyInput.dataset.field = "key";
    row.appendChild(keyInput);

    const equals = document.createElement("span");
    equals.className = "query-equals";
    equals.textContent = "=";
    row.appendChild(equals);

    const valueInput = document.createElement("input");
    valueInput.placeholder = "value";
    valueInput.value = param?.value || "";
    valueInput.dataset.field = "value";
    row.appendChild(valueInput);

    const actions = document.createElement("div");
    actions.className = "query-row-actions";

    const upBtn = document.createElement("button");
    upBtn.type = "button";
    upBtn.dataset.action = "up";
    upBtn.title = "Move up";
    upBtn.textContent = "↑";
    upBtn.disabled = index === 0;
    actions.appendChild(upBtn);

    const downBtn = document.createElement("button");
    downBtn.type = "button";
    downBtn.dataset.action = "down";
    downBtn.title = "Move down";
    downBtn.textContent = "↓";
    downBtn.disabled = index === params.length - 1;
    actions.appendChild(downBtn);

    const deleteBtn = document.createElement("button");
    deleteBtn.type = "button";
    deleteBtn.dataset.action = "delete";
    deleteBtn.classList.add("danger");
    deleteBtn.title = "Remove";
    deleteBtn.textContent = "✕";
    actions.appendChild(deleteBtn);

    row.appendChild(actions);
    elements.urlQueryTable.appendChild(row);
  });
}

function addUrlQueryRow() {
  if (!isUrlTool(state.currentTool)) return;
  const next = [...(state.urlQueryParams || []), { key: "", value: "" }];
  state.urlQueryParams = next;
  applyUrlQueryStateChange({ renderTable: true });
}

function handleUrlQueryTableInput(event) {
  if (!isUrlTool(state.currentTool)) return;
  const target = event.target;
  if (!(target instanceof HTMLInputElement)) return;
  const row = target.closest(".query-row");
  const field = target.dataset.field;
  if (!row || !field) return;
  const index = Number(row.dataset.index);
  if (Number.isNaN(index) || !state.urlQueryParams[index]) return;
  const next = [...state.urlQueryParams];
  const updated = { ...next[index], [field]: target.value };
  next[index] = updated;
  state.urlQueryParams = next;
  applyUrlQueryStateChange();
}

function handleUrlQueryTableClick(event) {
  if (!isUrlTool(state.currentTool)) return;
  const button = event.target.closest("button[data-action]");
  if (!button) return;
  const row = button.closest(".query-row");
  if (!row) return;
  const index = Number(row.dataset.index);
  if (Number.isNaN(index)) return;
  const action = button.dataset.action;
  if (action === "delete") {
    removeUrlQueryRow(index);
    return;
  }
  if (action === "up") {
    moveUrlQueryRow(index, -1);
    return;
  }
  if (action === "down") {
    moveUrlQueryRow(index, 1);
  }
}

function moveUrlQueryRow(index, delta) {
  const params = [...(state.urlQueryParams || [])];
  const targetIndex = index + delta;
  if (targetIndex < 0 || targetIndex >= params.length) return;
  const [item] = params.splice(index, 1);
  params.splice(targetIndex, 0, item);
  state.urlQueryParams = params;
  applyUrlQueryStateChange({ renderTable: true });
}

function removeUrlQueryRow(index) {
  const params = [...(state.urlQueryParams || [])];
  if (index < 0 || index >= params.length) return;
  params.splice(index, 1);
  state.urlQueryParams = params;
  applyUrlQueryStateChange({ renderTable: true });
}

function setPairField(target, value) {
  if (!target) return;
  state.pairSyncing = true;
  target.value = value || "";
  state.pairSyncing = false;
}

function updatePairMeta(info) {
  if (!elements.pairOutputMeta) return;
  if (!info || state.currentTool !== "coder-jwt") {
    elements.pairOutputMeta.classList.add("hidden");
    elements.pairOutputMeta.textContent = "";
    return;
  }
  const sections = [];
  if (info.header) {
    sections.push(`Header:\n${info.header}`);
  }
  if (info.signature) {
    sections.push(`Signature:\n${info.signature}`);
  }
  elements.pairOutputMeta.textContent = sections.join("\n\n");
  elements.pairOutputMeta.classList.toggle("hidden", sections.length === 0);
}

function activateNumberTool() {
  state.numberSyncing = true;
  [
    elements.numberBinary,
    elements.numberOctal,
    elements.numberDecimal,
    elements.numberHex,
  ].forEach((field) => {
    if (field) field.value = "";
  });
  state.numberSyncing = false;
  setStatus("Ready", false);
}

function handleNumberInput(base) {
  if (!isNumberTool(state.currentTool) || state.numberSyncing) return;
  runNumberConversion(base);
}

function runNumberConversion(base) {
  const fieldName = `number${capitalize(base)}`;
  const field = elements[fieldName];
  if (!field) return;
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
    return;
  }
  const value = field.value;
  if (!value.trim()) {
    state.numberSyncing = true;
    [
      elements.numberBinary,
      elements.numberOctal,
      elements.numberDecimal,
      elements.numberHex,
    ].forEach((input) => {
      if (input) input.value = "";
    });
    state.numberSyncing = false;
    setStatus("Cleared");
    return;
  }
  try {
    const result = convert_number_base(base, value) || {};
    state.numberSyncing = true;
    if (typeof result.binary === "string" && elements.numberBinary) {
      elements.numberBinary.value = result.binary;
    }
    if (typeof result.octal === "string" && elements.numberOctal) {
      elements.numberOctal.value = result.octal;
    }
    if (typeof result.decimal === "string" && elements.numberDecimal) {
      elements.numberDecimal.value = result.decimal;
    }
    if (typeof result.hex === "string" && elements.numberHex) {
      elements.numberHex.value = result.hex;
    }
    state.numberSyncing = false;
    setStatus("Done", false);
  } catch (err) {
    state.numberSyncing = false;
    setStatus(`⚠️ ${err?.message || err}`, true);
  }
}

function activateUnitTool() {
  clearUnitFields();
  setStatus("Ready", false);
}

function handleUnitInput(unitKey) {
  if (!isUnitTool(state.currentTool) || state.unitSyncing) return;
  runUnitConversion(unitKey);
}

function runUnitConversion(unitKey) {
  const fieldId = `unit${capitalize(unitKey)}`;
  const field = elements[fieldId];
  if (!field) return;
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
    return;
  }
  const value = field.value;
  if (!value.trim()) {
    clearUnitFields();
    setStatus("Cleared");
    return;
  }
  try {
    const result = convert_units(unitKey, value);
    const normalized = normalizeMapResult(result);
    state.unitSyncing = true;
    unitKeys.forEach((key) => {
      const target = elements[`unit${capitalize(key)}`];
      if (target && typeof normalized[key] === "string") {
        target.value = normalized[key];
      }
    });
    state.unitSyncing = false;
    setStatus("Done", false);
  } catch (err) {
    state.unitSyncing = false;
    setStatus(`⚠️ ${err?.message || err}`, true);
  }
}

function clearUnitFields() {
  state.unitSyncing = true;
  unitKeys.forEach((key) => {
    const target = elements[`unit${capitalize(key)}`];
    if (target) target.value = "";
  });
  state.unitSyncing = false;
}

function activateIPv4Tool() {
  if (elements.ipv4Results) {
    elements.ipv4Results.innerHTML =
      '<div class="muted">Enter an IP address (IPv4/IPv6), CIDR block, or range to see details</div>';
  }
  if (elements.ipv4Input) {
    elements.ipv4Input.value = "";
  }
  setStatus("Ready", false);
}

function runIPv4Conversion() {
  if (!isIPv4Tool(state.currentTool)) return;
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
    return;
  }
  const value = elements.ipv4Input?.value.trim() || "";
  if (!value) {
    if (elements.ipv4Results) {
      elements.ipv4Results.innerHTML =
        '<div class="muted">Enter an IP address (IPv4/IPv6), CIDR block, or range to see details</div>';
    }
    setStatus("Cleared");
    return;
  }
  try {
    const data = ipv4_info(value) || {};
    renderIPv4Results(data);
    setStatus("Done", false);
  } catch (err) {
    setStatus(`⚠️ ${err?.message || err}`, true);
  }
}

function renderIPv4Results(data) {
  if (!elements.ipv4Results) return;
  const stats = [];
  const addRow = (label, value) => {
    if (!value) return;
    stats.push(renderIPv4Row(label, value));
  };
  addRow("Version", data.version);
  addRow("Type", data.type);
  addRow("Standard", data.standard);
  addRow("CIDR", data.cidr);
  addRow("Mask", data.mask);
  addRow("Mask (binary)", data.maskBinary);
  addRow("IPv6 mapped", data.ipv6Mapped);
  if (data.rangeStart || data.rangeEnd) {
    addRow("Range", `${data.rangeStart || "?"} → ${data.rangeEnd || "?"}`);
  }
  addRow("Network", data.network);
  addRow("Broadcast", data.broadcast);
  addRow("Total IPs", data.total);
  addRow("3-part", data.threePart);
  addRow("2-part", data.twoPart);
  addRow("Integer", data.integer);
  addRow("Expanded", data.expanded);
  addRow("Compressed", data.compressed);
  addRow("Binary", data.binary);
  addRow("Host bits", data.hostBits);
  if (!stats.length) {
    elements.ipv4Results.innerHTML =
      '<div class="muted">Unable to parse input</div>';
    return;
  }
  elements.ipv4Results.innerHTML = `<div class="ipv4-stats">${stats.join("")}</div>`;
}

function renderIPv4Row(label, value) {
  const safeLabel = escapeHTML(label || "");
  const safeValue = escapeHTML(value || "");
  const attrValue = escapeAttr(value || "");
  return `
    <div class="stat">
      <span>${safeLabel}</span>
      <span class="click-copy" data-copy-value="${attrValue}">${safeValue}</span>
    </div>
  `;
}

function activateUUIDTool() {
  state.uuidUppercase = false;
  if (elements.uuidToggleCase) {
    elements.uuidToggleCase.dataset.upper = "false";
  }
  if (!state.wasmReady) {
    if (elements.uuidList) {
      elements.uuidList.innerHTML =
        '<div class="muted">Waiting for WebAssembly...</div>';
    }
    return;
  }
  refreshUUIDs(true);
}

function refreshUUIDs(force = false) {
  if (!isUUIDTool(state.currentTool) || !state.wasmReady) return;
  if (!force && Object.keys(state.currentUUIDs).length) {
    renderUUIDs();
    return;
  }
  try {
    const result = generate_uuids();
    state.currentUUIDs = normalizeUuidResult(result);
    renderUUIDs();
    setStatus("Generated new UUIDs", false);
  } catch (err) {
    console.error(err);
    setStatus(`⚠️ ${err.message}`, true);
  }
}

function renderUUIDs() {
  if (!elements.uuidList) return;
  const entries = [];
  const seen = new Set();
  uuidDisplayOrder.forEach((key) => {
    if (state.currentUUIDs[key]) {
      entries.push([key, state.currentUUIDs[key]]);
      seen.add(key);
    }
  });
  Object.keys(state.currentUUIDs).forEach((key) => {
    if (!seen.has(key)) {
      entries.push([key, state.currentUUIDs[key]]);
    }
  });
  if (!entries.length) {
    elements.uuidList.innerHTML =
      '<div class="muted">No UUIDs generated yet</div>';
    return;
  }
  const rows = entries
    .map(([version, value]) => {
      const display = state.uuidUppercase
        ? value.toUpperCase()
        : value.toLowerCase();
      const label = uuidDisplayLabels[version] || version.toUpperCase();
      return `
        <div class="uuid-row" data-value="${escapeAttr(display)}" data-label="${escapeAttr(label)}">
          <span>${label}</span>
          <code>${escapeHTML(display)}</code>
          <button type="button" class="uuid-copy">Copy</button>
        </div>
      `;
    })
    .join("");
  elements.uuidList.innerHTML = rows;
  elements.uuidList.querySelectorAll(".uuid-copy").forEach((btn) => {
    btn.addEventListener("click", () => {
      const row = btn.closest(".uuid-row");
      if (!row) return;
      const value = row.dataset.value || "";
      const label = row.dataset.label || "UUID";
      if (!value) return;
      copyText(value, label);
    });
  });
}

function activateUserAgentTool() {
  state.currentBrowserFilter = elements.uaBrowser?.value || "";
  state.currentOSFilter = elements.uaOS?.value || "";
  if (!state.wasmReady) {
    if (elements.uaResults) {
      elements.uaResults.innerHTML =
        '<div class="muted">Waiting for WebAssembly...</div>';
    }
    return;
  }
  refreshUserAgents(true);
}

function refreshUserAgents(force = false) {
  if (!isUserAgentTool(state.currentTool) || !state.wasmReady) return;
  const browser = elements.uaBrowser?.value || "";
  const os = elements.uaOS?.value || "";
  const sameFilters =
    browser === state.currentBrowserFilter && os === state.currentOSFilter;
  if (!force && sameFilters && state.currentUserAgents.length) {
    renderUserAgents(state.currentUserAgents);
    return;
  }
  state.currentBrowserFilter = browser;
  state.currentOSFilter = os;
  try {
    const list = generate_user_agents(browser, os);
    state.currentUserAgents = Array.isArray(list) ? list : [];
    renderUserAgents(state.currentUserAgents);
    setStatus("Generated user agents", false);
  } catch (err) {
    console.error(err);
    setStatus(`⚠️ ${err.message}`, true);
  }
}

function renderUserAgents(list) {
  if (!elements.uaResults) return;
  if (!list.length) {
    elements.uaResults.innerHTML =
      '<div class="muted">No user agents for this filter</div>';
    return;
  }
  const cards = list
    .map((entry) => {
      const browserName = entry.browserName || "Unknown";
      const browserVersion = entry.browserVersion || "";
      const osName = entry.osName || "Unknown";
      const osVersion = entry.osVersion || "";
      const engineName = entry.engineName || "Unknown";
      const engineVersion = entry.engineVersion || "";
      const browserText = browserVersion
        ? `${browserName} ${browserVersion}`
        : browserName;
      const osText = osVersion ? `${osName} ${osVersion}` : osName;
      const engineText = engineVersion
        ? `${engineName} ${engineVersion}`
        : engineName;
      const ua = entry.userAgent || "";
      return `
        <div class="ua-card" data-ua="${escapeAttr(ua)}" title="Click to copy">
          <code>${escapeHTML(ua)}</code>
          <div class="ua-meta">
            <span><strong>Browser:</strong> ${escapeHTML(browserText)}</span>
            <span><strong>OS:</strong> ${escapeHTML(osText)}</span>
            <span><strong>Engine:</strong> ${escapeHTML(engineText)}</span>
          </div>
        </div>
      `;
    })
    .join("");
  elements.uaResults.innerHTML = cards;
  elements.uaResults.querySelectorAll(".ua-card").forEach((card) => {
    card.addEventListener("click", () => {
      const value = card.dataset.ua || "";
      if (!value) return;
      copyText(value, "user agent");
    });
  });
}

// Fingerprint workspace: collect passive browser/device signals (no external calls or permissions).
function activateFingerprintTool() {
  refreshFingerprint(true);
}

function refreshFingerprint(silent = false) {
  if (!isFingerprintTool(state.currentTool)) return;
  const facts = collectFingerprintFacts();
  state.fingerprintFacts = facts;
  renderFingerprintFacts(facts);
  runFingerprintAsyncEnrichments();
  if (!silent) setStatus("Fingerprint refreshed", false);
}

function collectFingerprintFacts() {
  const facts = [];
  const add = (group, label, value) => {
    if (value === undefined || value === null || value === "") return;
    facts.push({ group, label, value: String(value) });
  };
  const upsert = (group, label, value) =>
    upsertFact(group, label, value, facts);
  // Categories roughly mirror how the UI nests the list for readability.
  const nav = typeof navigator !== "undefined" ? navigator : {};
  const uaData = nav.userAgentData;
  // Identity & Browser
  add("Identity", "User-Agent", nav.userAgent || "");
  add(
    "Identity",
    "UA-CH Brands",
    uaData?.brands?.map((b) => `${b.brand} ${b.version}`).join(", "),
  );
  add("Identity", "UA-CH Mobile", uaData?.mobile);
  add("Identity", "UA-CH Platform", uaData?.platform || "");
  add("Identity", "Platform", nav.platform || "");
  add("Identity", "Vendor", nav.vendor || "");
  add("Identity", "Product", nav.product || "");
  add("Identity", "App Version", nav.appVersion || "");
  add("Identity", "WebDriver", nav.webdriver === true ? "Yes" : "No");
  add("Identity", "On Line", nav.onLine === false ? "No" : "Yes");
  add(
    "Identity",
    "Window Properties",
    typeof window !== "undefined"
      ? Object.getOwnPropertyNames(window).length
      : "",
  );
  const stackProbe = (() => {
    try {
      throw new Error("fp-stack-probe");
    } catch (err) {
      const msg =
        typeof err?.stack === "string" ? err.stack.split("\n")[1]?.trim() : "";
      return msg || err?.message || "";
    }
  })();
  add("Identity", "Error Stack Sig", stackProbe);
  add("Identity", "WebDriver", nav.webdriver === true ? "Yes" : "No");
  add("Identity", "On Line", nav.onLine === false ? "No" : "Yes");

  // Locale / Time
  const langList = Array.isArray(nav.languages) ? nav.languages : [];
  add("Locale & Time", "Primary Language", nav.language || "");
  add("Locale & Time", "Languages", langList.join(", "));
  const tz = Intl?.DateTimeFormat?.().resolvedOptions?.().timeZone;
  if (tz) add("Locale & Time", "Time Zone", tz);
  const offset = formatTimezoneOffset(new Date().getTimezoneOffset());
  add("Locale & Time", "UTC Offset", offset);
  add(
    "Locale & Time",
    "Calendar",
    Intl?.DateTimeFormat?.().resolvedOptions?.().calendar || "",
  );
  add(
    "Locale & Time",
    "Numbering System",
    Intl?.DateTimeFormat?.().resolvedOptions?.().numberingSystem || "",
  );
  add(
    "Locale & Time",
    "Calendar",
    Intl?.DateTimeFormat?.().resolvedOptions?.().calendar || "",
  );
  add(
    "Locale & Time",
    "Numbering System",
    Intl?.DateTimeFormat?.().resolvedOptions?.().numberingSystem || "",
  );

  // Hardware
  if (typeof nav.hardwareConcurrency === "number") {
    add("Hardware", "Logical CPUs", nav.hardwareConcurrency);
  }
  if (typeof nav.deviceMemory === "number") {
    add("Hardware", "Device Memory", `${nav.deviceMemory} GB`);
  }
  add("Hardware", "Max Touch Points", nav.maxTouchPoints ?? "");
  if (typeof window !== "undefined") {
    add("Hardware", "Device Pixel Ratio", window.devicePixelRatio || "");
  }
  add("Hardware", "WebDriver", nav.webdriver === true ? "Yes" : "No");

  // Screen
  const screenObj = typeof window !== "undefined" ? window.screen : null;
  if (screenObj) {
    add("Screen", "Size", `${screenObj.width} × ${screenObj.height}`);
    add(
      "Screen",
      "Available",
      `${screenObj.availWidth} × ${screenObj.availHeight}`,
    );
    add("Screen", "Color Depth", `${screenObj.colorDepth}-bit`);
    if (screenObj.orientation?.type) {
      add("Screen", "Orientation", screenObj.orientation.type);
      if (typeof screenObj.orientation.angle === "number") {
        add("Screen", "Orientation Angle", `${screenObj.orientation.angle}°`);
      }
    }
    if (typeof screenObj.pixelDepth === "number") {
      add("Screen", "Pixel Depth", `${screenObj.pixelDepth}-bit`);
    }
  }
  if (typeof window !== "undefined") {
    add("Screen", "Inner Size", `${window.innerWidth} × ${window.innerHeight}`);
    add("Screen", "Outer Size", `${window.outerWidth} × ${window.outerHeight}`);
    const scrollbar =
      window.innerWidth && document?.documentElement?.clientWidth
        ? window.innerWidth - document.documentElement.clientWidth
        : "";
    if (scrollbar !== "") add("Screen", "Scrollbar Width", `${scrollbar}px`);
  }

  // Storage / Capabilities
  add("Capabilities", "Cookies Enabled", nav.cookieEnabled ? "Yes" : "No");
  add(
    "Capabilities",
    "LocalStorage",
    storageAvailable("localStorage") ? "Yes" : "No",
  );
  add(
    "Capabilities",
    "SessionStorage",
    storageAvailable("sessionStorage") ? "Yes" : "No",
  );
  add("Capabilities", "IndexedDB", "indexedDB" in window ? "Yes" : "No");
  add(
    "Capabilities",
    "Service Worker",
    "serviceWorker" in navigator ? "Yes" : "No",
  );
  add(
    "Capabilities",
    "Notifications",
    typeof Notification !== "undefined"
      ? Notification.permission
      : "Unavailable",
  );
  add(
    "Capabilities",
    "PDF Viewer Plugins",
    typeof nav.plugins?.length === "number" ? nav.plugins.length : "",
  );
  add("Capabilities", "Save-Data", nav.connection?.saveData ? "Yes" : "No");
  add("Capabilities", "Clipboard API", "clipboard" in navigator ? "Yes" : "No");
  add("Capabilities", "Gamepad API", !!navigator.getGamepads ? "Yes" : "No");
  add("Capabilities", "MediaDevices", !!navigator.mediaDevices ? "Yes" : "No");
  add(
    "Capabilities",
    "share()",
    typeof navigator.share === "function" ? "Yes" : "No",
  );
  add(
    "Capabilities",
    "canShare()",
    typeof navigator.canShare === "function" ? "Yes" : "No",
  );
  add(
    "Capabilities",
    "Protocol Handler",
    typeof navigator.registerProtocolHandler === "function" ? "Yes" : "No",
  );
  add(
    "Capabilities",
    "Content Handler",
    typeof navigator.registerContentHandler === "function" ? "Yes" : "No",
  );
  add(
    "Capabilities",
    "Storage Access API",
    typeof document?.hasStorageAccess === "function" ? "Yes" : "No",
  );
  add(
    "Capabilities",
    "Cache API",
    typeof caches !== "undefined" ? "Yes" : "No",
  );
  add(
    "Capabilities",
    "Secure Context",
    typeof window !== "undefined" && window.isSecureContext ? "Yes" : "No",
  );

  // Network
  const connection =
    nav.connection || nav.mozConnection || nav.webkitConnection || null;
  if (connection) {
    add("Network", "Effective Type", connection.effectiveType || "");
    if (typeof connection.downlink === "number") {
      add("Network", "Downlink", `${connection.downlink} Mb/s`);
    }
    if (typeof connection.rtt === "number") {
      add("Network", "RTT", `${connection.rtt} ms`);
    }
    if (typeof connection.downlinkMax === "number") {
      add("Network", "Downlink Max", `${connection.downlinkMax} Mb/s`);
    }
  }

  // Graphics
  const webgl = getWebGLInfo();
  add("Graphics", "WebGL Vendor", webgl.vendor || "");
  add("Graphics", "WebGL Renderer", webgl.renderer || "");
  add("Graphics", "WebGL Version", webgl.version || "");
  if (webgl.extensions) {
    add(
      "Graphics",
      "WebGL Extensions",
      webgl.extensions.slice(0, 6).join(", ") +
        (webgl.extensions.length > 6 ? " …" : ""),
    );
  }
  if (webgl.limits) {
    add("Graphics", "Max Texture Size", webgl.limits.maxTextureSize);
    add("Graphics", "Max Vertex Attribs", webgl.limits.maxVertexAttribs);
  }
  const canvasHash = generateCanvasHash();
  if (canvasHash) add("Graphics", "Canvas Fingerprint", canvasHash);
  const audioInfo = getAudioContextInfo();
  add("Graphics", "AudioContext", audioInfo.context);
  add("Graphics", "Audio Hash", audioInfo.hash);
  add(
    "Graphics",
    "PointerEvent Support",
    typeof window !== "undefined" && "PointerEvent" in window ? "Yes" : "No",
  );

  // Performance
  const perf = typeof performance !== "undefined" ? performance : null;
  if (perf?.memory) {
    add(
      "Performance",
      "JS Heap Limit",
      formatBytes(perf.memory.jsHeapSizeLimit),
    );
    add("Performance", "JS Heap Used", formatBytes(perf.memory.usedJSHeapSize));
  }
  const resolution = measureTimeResolution();
  if (resolution) add("Performance", "Timer Resolution", resolution);

  const media = detectMediaFeatures();
  Object.entries(media).forEach(([key, value]) =>
    add("Media Queries", key, value),
  );

  const feature = detectFeatureSupport();
  Object.entries(feature).forEach(([key, value]) =>
    add("Feature Support", key, value),
  );

  // Authentication / Security
  add(
    "Auth",
    "WebAuthn",
    typeof window !== "undefined" && "PublicKeyCredential" in window
      ? "Yes"
      : "No",
  );

  // XR placeholder; async probe will refine.
  add(
    "XR",
    "WebXR",
    typeof navigator !== "undefined" && "xr" in navigator ? "Probing…" : "No",
  );

  // WebGPU placeholder; async probe will refine.
  add(
    "Graphics",
    "WebGPU",
    typeof navigator !== "undefined" && navigator.gpu ? "Probing…" : "No",
  );

  return dedupeFacts(facts);
}

function renderFingerprintFacts(facts = []) {
  if (elements.fingerprintSummary) {
    const total = facts.length || 0;
    elements.fingerprintSummary.textContent = total
      ? `${total} signals collected from this browser`
      : "No data available";
  }
  if (!elements.fingerprintGrid) return;
  if (!facts.length) {
    elements.fingerprintGrid.innerHTML =
      '<div class="muted">No data detected.</div>';
    return;
  }
  const groups = facts.reduce((acc, fact) => {
    const key = fact.group || "Other";
    if (!acc[key]) acc[key] = [];
    acc[key].push(fact);
    return acc;
  }, {});
  const sections = Object.keys(groups)
    .sort()
    .map((group) => {
      const items = groups[group]
        .map((entry) => {
          const label = escapeHTML(entry.label || "");
          const value = escapeHTML(entry.value || "");
          return `<li><span class="fp-label">${label}</span><code>${value}</code></li>`;
        })
        .join("");
      return `<div class="fingerprint-group"><h3>${escapeHTML(group)}</h3><ul class="fingerprint-list">${items}</ul></div>`;
    })
    .join("");
  elements.fingerprintGrid.innerHTML = sections;
}

function storageAvailable(type) {
  try {
    const storage = window[type];
    const test = "__transform_fp__";
    storage.setItem(test, "1");
    storage.removeItem(test);
    return true;
  } catch (_err) {
    return false;
  }
}

function formatTimezoneOffset(offsetMinutes) {
  if (!Number.isFinite(offsetMinutes)) return "";
  const total = Math.abs(offsetMinutes);
  const hours = String(Math.floor(total / 60)).padStart(2, "0");
  const minutes = String(total % 60).padStart(2, "0");
  const sign = offsetMinutes <= 0 ? "+" : "-";
  return `${sign}${hours}:${minutes}`;
}

function formatBytes(bytes) {
  if (!Number.isFinite(bytes)) return "";
  const units = ["B", "KB", "MB", "GB", "TB"];
  let value = bytes;
  let unit = 0;
  while (value >= 1024 && unit < units.length - 1) {
    value /= 1024;
    unit += 1;
  }
  return `${value.toFixed(1)} ${units[unit]}`;
}

function measureTimeResolution() {
  if (
    typeof performance === "undefined" ||
    typeof performance.now !== "function"
  )
    return "";
  let min = Infinity;
  let last = performance.now();
  for (let i = 0; i < 40; i++) {
    const now = performance.now();
    const delta = now - last;
    if (delta > 0 && delta < min) {
      min = delta;
    }
    last = now;
  }
  if (!Number.isFinite(min) || min === Infinity) return "";
  return `${min.toFixed(3)} ms (min delta)`;
}

function detectMediaFeatures() {
  const query = (q) =>
    typeof window !== "undefined" && window.matchMedia
      ? window.matchMedia(q).matches
      : "Unknown";
  return {
    "prefers-color-scheme: dark": query("(prefers-color-scheme: dark)")
      ? "Yes"
      : "No",
    "prefers-reduced-motion": query("(prefers-reduced-motion: reduce)")
      ? "Reduce"
      : "No",
    "pointer: fine": query("(pointer: fine)") ? "Yes" : "No",
    "hover: hover": query("(hover: hover)") ? "Yes" : "No",
  };
}

function detectFeatureSupport() {
  if (typeof document === "undefined") return {};
  const supports = (prop, value) =>
    typeof CSS !== "undefined" && CSS.supports
      ? CSS.supports(prop, value)
      : false;
  return {
    "CSS Backdrop Filter": supports("backdrop-filter", "blur(4px)")
      ? "Yes"
      : "No",
    "CSS Subgrid": supports("display", "subgrid") ? "Yes" : "No",
    IntersectionObserver: "IntersectionObserver" in window ? "Yes" : "No",
    "Clipboard API": "clipboard" in navigator ? "Yes" : "No",
    "Gamepad API": "getGamepads" in navigator ? "Yes" : "No",
  };
}

function generateCanvasHash() {
  try {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    if (!ctx) return "";
    canvas.width = 240;
    canvas.height = 60;
    ctx.textBaseline = "top";
    ctx.font = "16px 'Arial'";
    ctx.fillStyle = "#f60";
    ctx.fillRect(125, 1, 62, 20);
    ctx.fillStyle = "#069";
    ctx.fillText("transform-fp", 2, 10);
    ctx.strokeStyle = "#fff";
    ctx.strokeText("transform-fp", 2, 10);
    const data = canvas.toDataURL();
    return hashString(data).slice(0, 16);
  } catch (_err) {
    return "";
  }
}

function getWebGLInfo() {
  try {
    const canvas = document.createElement("canvas");
    const gl =
      canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
    if (!gl) return {};
    const debugInfo = gl.getExtension("WEBGL_debug_renderer_info");
    const vendor = debugInfo
      ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL)
      : gl.getParameter(gl.VENDOR);
    const renderer = debugInfo
      ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
      : gl.getParameter(gl.RENDERER);
    const version = gl.getParameter(gl.VERSION);
    const extensions = gl.getSupportedExtensions() || [];
    const limits = {
      maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
      maxVertexAttribs: gl.getParameter(gl.MAX_VERTEX_ATTRIBS),
    };
    return {
      vendor,
      renderer,
      version,
      extensions,
      limits,
    };
  } catch (_err) {
    return {};
  }
}

function getAudioContextInfo() {
  try {
    const AudioCtx =
      window.OfflineAudioContext || window.webkitOfflineAudioContext;
    if (!AudioCtx) {
      return { context: "Unavailable", hash: "" };
    }
    const context = new AudioCtx(1, 512, 44100);
    const osc = context.createOscillator();
    const compressor = context.createDynamicsCompressor();
    osc.type = "triangle";
    osc.frequency.value = 1000;
    compressor.threshold.value = -50;
    compressor.knee.value = 40;
    compressor.ratio.value = 12;
    compressor.attack.value = 0;
    compressor.release.value = 0.25;
    osc.connect(compressor);
    compressor.connect(context.destination);
    osc.start(0);
    const bufferPromise = context.startRendering();
    // OfflineAudioContext renders async; we expose a stable hash string when ready.
    bufferPromise.then((buffer) => {
      const channel = buffer.getChannelData(0) || new Float32Array(0);
      const hash = hashArray(channel);
      state.fingerprintFacts = state.fingerprintFacts.map((entry) =>
        entry.label === "Audio Hash" ? { ...entry, value: hash } : entry,
      );
      renderFingerprintFacts(state.fingerprintFacts);
    });
    return { context: "OfflineAudioContext", hash: "Rendering…" };
  } catch (_err) {
    return { context: "Error", hash: "" };
  }
}

function runFingerprintAsyncEnrichments() {
  probeUAHighEntropy();
  probeWebGPU();
  probeWebXR();
  probeWebAuthn();
}

async function probeUAHighEntropy() {
  try {
    const nav = typeof navigator !== "undefined" ? navigator : {};
    if (!nav.userAgentData?.getHighEntropyValues) return;
    const fields = [
      "architecture",
      "model",
      "platformVersion",
      "uaFullVersion",
      "bitness",
      "wow64",
      "formFactor",
    ];
    const info = await nav.userAgentData.getHighEntropyValues(fields);
    fields.forEach((key) => {
      if (info[key]) {
        upsertFact("Identity", `UA-CH ${capitalize(key)}`, info[key]);
      }
    });
    renderFingerprintFacts(state.fingerprintFacts);
  } catch (_err) {
    // ignore; some browsers deny access
  }
}

async function probeWebGPU() {
  try {
    if (typeof navigator === "undefined" || !navigator.gpu) return;
    upsertFact("Graphics", "WebGPU", "Supported (probing adapter)");
    const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) {
      upsertFact("Graphics", "WebGPU", "No adapter");
      renderFingerprintFacts(state.fingerprintFacts);
      return;
    }
    upsertFact("Graphics", "WebGPU Adapter", adapter.name || "");
    const features = adapter.features ? Array.from(adapter.features) : [];
    if (features.length) {
      upsertFact(
        "Graphics",
        "WebGPU Features",
        features.slice(0, 6).join(", ") + (features.length > 6 ? " …" : ""),
      );
    }
    const limits = adapter.limits || {};
    if (limits.maxTextureDimension2D) {
      upsertFact(
        "Graphics",
        "WebGPU MaxTexture2D",
        limits.maxTextureDimension2D,
      );
    }
    renderFingerprintFacts(state.fingerprintFacts);
  } catch (_err) {
    // ignore
  }
}

async function probeWebXR() {
  try {
    if (typeof navigator === "undefined" || !navigator.xr) return;
    upsertFact("XR", "WebXR", "Supported (probing)");
    const modes = ["immersive-vr", "immersive-ar", "inline"];
    for (const mode of modes) {
      try {
        const supported = await navigator.xr.isSessionSupported(mode);
        upsertFact("XR", `${mode} supported`, supported ? "Yes" : "No");
      } catch (_err) {
        // continue
      }
    }
    renderFingerprintFacts(state.fingerprintFacts);
  } catch (_err) {
    // ignore
  }
}

async function probeWebAuthn() {
  try {
    if (typeof window === "undefined" || !("PublicKeyCredential" in window))
      return;
    if (
      typeof PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable !==
      "function"
    )
      return;
    const available =
      await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
    upsertFact("Auth", "Platform Authenticator", available ? "Yes" : "No");
    renderFingerprintFacts(state.fingerprintFacts);
  } catch (_err) {
    // ignore
  }
}

function upsertFact(group, label, value, targetFacts = state.fingerprintFacts) {
  if (value === undefined || value === null || value === "") return;
  const idx = targetFacts.findIndex(
    (entry) => entry.group === group && entry.label === label,
  );
  const payload = { group, label, value: String(value) };
  if (idx >= 0) {
    targetFacts[idx] = payload;
  } else {
    targetFacts.push(payload);
  }
}

function dedupeFacts(list = []) {
  const seen = new Set();
  return list.filter((entry) => {
    const key = `${entry.group}::${entry.label}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });
}

function hashArray(arr) {
  let hash = 0;
  for (let i = 0; i < arr.length; i += 16) {
    hash = (hash << 5) - hash + Math.floor(arr[i] * 1e6);
    hash |= 0;
  }
  return `a${Math.abs(hash).toString(16)}`;
}

function hashString(input) {
  let hash = 0;
  if (!input) return "";
  for (let i = 0; i < input.length; i++) {
    hash = (hash << 5) - hash + input.charCodeAt(i);
    hash |= 0;
  }
  return `h${Math.abs(hash).toString(16)}`;
}

function renderSymbolButtons() {
  if (!elements.randomSymbolToggles) return;
  const buttons = specialCharacters
    .map((symbol) => {
      const isActive = state.randomSymbols?.has(symbol);
      return `<button type="button" data-symbol="${escapeAttr(symbol)}" data-active="${isActive ? "true" : "false"}">${escapeHTML(symbol)}</button>`;
    })
    .join("");
  elements.randomSymbolToggles.innerHTML = buttons;
  syncSymbolButtons();
  updateSymbolMinState();
}

function syncSymbolButtons() {
  if (!elements.randomSymbolToggles) return;
  elements.randomSymbolToggles
    .querySelectorAll("button[data-symbol]")
    .forEach((button) => {
      const symbol = button.dataset.symbol || "";
      const isActive = state.randomSymbols?.has(symbol);
      button.dataset.active = isActive ? "true" : "false";
    });
}

function handleRandomSymbolToggle(event) {
  const button = event.target.closest("button[data-symbol]");
  if (!button) return;
  const symbol = button.dataset.symbol || "";
  if (!state.randomSymbols) {
    state.randomSymbols = new Set();
  }
  const active = button.dataset.active !== "false";
  if (active) {
    state.randomSymbols.delete(symbol);
    button.dataset.active = "false";
  } else {
    state.randomSymbols.add(symbol);
    button.dataset.active = "true";
  }
  updateSymbolMinState();
  validateMinimumTotals(true);
}

function activateRandomTool() {
  if (elements.randomIncludeDigits) {
    elements.randomIncludeDigits.checked = state.randomIncludeDigits;
  }
  if (elements.randomLength) {
    elements.randomLength.value = state.randomLength;
  }
  if (elements.randomCount) {
    elements.randomCount.value = state.randomCount;
  }
  if (elements.randomAllowZero) {
    elements.randomAllowZero.checked = state.randomAllowLeadingZero;
  }
  if (elements.randomIncludeLower) {
    elements.randomIncludeLower.checked = state.randomIncludeLower;
  }
  if (elements.randomIncludeUpper) {
    elements.randomIncludeUpper.checked = state.randomIncludeUpper;
  }
  if (elements.randomExclude) {
    elements.randomExclude.value = state.randomExclude;
  }
  updateMinInputStates();
  updateSymbolMinState();
  syncSymbolButtons();
  updateRandomZeroControl();
  updateRandomResults(state.randomResults);
  setStatus("Ready", false);
}

function updateRandomZeroControl() {
  if (!elements.randomAllowZero) return;
  if (elements.randomAllowZeroRow) {
    elements.randomAllowZeroRow.classList.toggle(
      "hidden",
      !state.randomIncludeDigits,
    );
  }
  if (!state.randomIncludeDigits) {
    state.randomAllowLeadingZero = false;
    elements.randomAllowZero.checked = false;
    elements.randomAllowZero.disabled = true;
  } else {
    elements.randomAllowZero.disabled = false;
    elements.randomAllowZero.checked = state.randomAllowLeadingZero;
  }
}

function handleRandomMinChange(kind) {
  const config = minCountConfig[kind];
  if (!config) return;
  const el = elements[config.elementKey];
  if (!el) return;
  let value = parseInt(el.value, 10);
  if (!Number.isFinite(value) || value < 0) {
    value = 0;
  }
  const max = Math.max(0, Number(state.randomLength) || 0);
  if (value > max) {
    value = max;
  }
  state[config.stateKey] = value;
  el.value = value;
  validateMinimumTotals(true);
}

function updateMinInputStates() {
  setMinInputState("digits", state.randomIncludeDigits);
  setMinInputState("lower", state.randomIncludeLower);
  setMinInputState("upper", state.randomIncludeUpper);
}

function setMinInputState(kind, enabled) {
  const config = minCountConfig[kind];
  if (!config) return;
  const el = elements[config.elementKey];
  if (!el) return;
  el.disabled = !enabled;
  el.classList.toggle("hidden", !enabled);
  if (!enabled) {
    state[config.stateKey] = 0;
    el.value = 0;
  } else {
    el.value = state[config.stateKey] || 0;
  }
  if (enabled) {
    handleRandomMinChange(kind);
  } else {
    validateMinimumTotals(false);
  }
}

function updateSymbolMinState() {
  const el = elements.randomMinSymbols;
  if (!el) return;
  const hasSymbols = state.randomSymbols && state.randomSymbols.size > 0;
  if (elements.randomSymbolMinRow) {
    elements.randomSymbolMinRow.classList.toggle("hidden", !hasSymbols);
  }
  el.disabled = !hasSymbols;
  if (!hasSymbols) {
    state.randomMinSymbols = 0;
    el.value = 0;
  } else {
    el.value = state.randomMinSymbols || 0;
  }
  validateMinimumTotals(false);
}

function validateMinimumTotals(showWarning = false) {
  const { minDigits, minLower, minUpper, minSymbols } = getMinimumCounts();
  const total = minDigits + minLower + minUpper + minSymbols;
  if (total > state.randomLength) {
    if (showWarning) {
      setStatus("Minimum counts exceed length", true);
    }
    return false;
  }
  return true;
}

function getMinimumCounts() {
  if (!state.randomSymbols) {
    state.randomSymbols = new Set();
  }
  const symbolSet = state.randomSymbols;
  const hasSymbols = symbolSet.size > 0;
  return {
    minDigits: state.randomIncludeDigits ? state.randomMinDigits || 0 : 0,
    minLower: state.randomIncludeLower ? state.randomMinLower || 0 : 0,
    minUpper: state.randomIncludeUpper ? state.randomMinUpper || 0 : 0,
    minSymbols: hasSymbols ? state.randomMinSymbols || 0 : 0,
    hasSymbols,
  };
}

function handleRandomLengthChange() {
  if (!elements.randomLength) return;
  let value = parseInt(elements.randomLength.value, 10);
  if (!Number.isFinite(value)) {
    value = 1;
  }
  value = Math.min(Math.max(value, 1), 2048);
  state.randomLength = value;
  elements.randomLength.value = value;
  validateMinimumTotals(true);
}

function handleRandomCountChange() {
  if (!elements.randomCount) return;
  let value = parseInt(elements.randomCount.value, 10);
  if (!Number.isFinite(value)) {
    value = 1;
  }
  value = Math.min(Math.max(value, 1), 256);
  state.randomCount = value;
  elements.randomCount.value = value;
}

function handleRandomIncludeDigitsChange(event) {
  state.randomIncludeDigits = Boolean(event?.target?.checked);
  updateRandomZeroControl();
  if (!state.randomIncludeDigits) {
    state.randomMinDigits = 0;
    if (elements.randomMinDigits) elements.randomMinDigits.value = 0;
  }
  updateMinInputStates();
  validateMinimumTotals(true);
}

function handleRandomLeadingToggle(event) {
  state.randomAllowLeadingZero = Boolean(event?.target?.checked);
  updateRandomZeroControl();
}

function handleRandomIncludeLowerChange(event) {
  state.randomIncludeLower = Boolean(event?.target?.checked);
  if (!state.randomIncludeLower) {
    state.randomMinLower = 0;
    if (elements.randomMinLower) elements.randomMinLower.value = 0;
  }
  updateMinInputStates();
  validateMinimumTotals(true);
}

function handleRandomIncludeUpperChange(event) {
  state.randomIncludeUpper = Boolean(event?.target?.checked);
  if (!state.randomIncludeUpper) {
    state.randomMinUpper = 0;
    if (elements.randomMinUpper) elements.randomMinUpper.value = 0;
  }
  updateMinInputStates();
  validateMinimumTotals(true);
}

function handleRandomExcludeInput() {
  if (!elements.randomExclude) return;
  const sanitized = sanitizeRandomExclude(elements.randomExclude.value || "");
  state.randomExclude = sanitized;
  elements.randomExclude.value = sanitized;
}

function runRandomGenerator() {
  if (!isRandomTool(state.currentTool)) {
    setStatus("Select the Random tool", true);
    return;
  }
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
    return;
  }
  handleRandomLengthChange();
  handleRandomCountChange();
  handleRandomExcludeInput();
  if (!validateMinimumTotals(true)) {
    return;
  }
  if (!state.randomSymbols) {
    state.randomSymbols = new Set();
  }
  const symbolSet = state.randomSymbols;
  const { minDigits, minLower, minUpper, minSymbols, hasSymbols } =
    getMinimumCounts();
  if (
    !state.randomIncludeDigits &&
    !state.randomIncludeLower &&
    !state.randomIncludeUpper &&
    !hasSymbols
  ) {
    setStatus("Select at least one character set", true);
    return;
  }
  const digits = state.randomIncludeDigits ? digitCharacters : "";
  const symbols = hasSymbols ? Array.from(symbolSet).join("") : "";
  try {
    const result = random_number_sequences(
      state.randomLength,
      state.randomCount,
      state.randomAllowLeadingZero,
      digits,
      state.randomIncludeLower,
      state.randomIncludeUpper,
      symbols,
      state.randomExclude,
      minDigits,
      minLower,
      minUpper,
      minSymbols,
    );
    const list = Array.isArray(result)
      ? result.map((item) => String(item || ""))
      : [];
    updateRandomResults(list);
    setStatus("Done", false);
  } catch (err) {
    updateRandomResults([]);
    setStatus(`⚠️ ${err?.message || err}`, true);
  }
}

function updateRandomResults(values) {
  state.randomResults = Array.isArray(values)
    ? values.filter((value) => typeof value === "string" && value.length > 0)
    : [];
  if (!elements.randomResults) return;
  if (!state.randomResults.length) {
    elements.randomResults.innerHTML =
      '<div class="random-placeholder">Click Generate to produce strings</div>';
    return;
  }
  const items = state.randomResults
    .map(
      (value) => `
        <div class="random-result-item" data-random-value="${escapeAttr(value)}">
          ${escapeHTML(value)}
        </div>
      `,
    )
    .join("");
  elements.randomResults.innerHTML = items;
}

function handleRandomResultsClick(event) {
  const row = event.target.closest(".random-result-item");
  if (!row) return;
  const value = row.dataset.randomValue || "";
  if (!value) return;
  copyText(value, "Random string");
}

function handleHashEncodingChange(event) {
  const value = event?.target?.value || "base16";
  state.hashEncoding = value;
  if (state.lastHashResults) renderHashResults(state.lastHashResults);
}

function handleHashModeToggle(event) {
  state.hashUseHmac = Boolean(event?.target?.checked);
  if (elements.hashHmacSecret) {
    elements.hashHmacSecret.classList.toggle("hidden", !state.hashUseHmac);
  }
  if (state.lastHashResults) renderHashResults(state.lastHashResults);
  scheduleCoder(true);
}

function handleHashSecretInput(event) {
  state.hashHmacSecret = event?.target?.value || "";
  if (state.hashUseHmac) {
    scheduleCoder(true);
  }
}

function handleTimestampPreset(event) {
  const button = event.target.closest("button[data-preset]");
  if (!button) return;
  const preset = button.dataset.preset;
  const entry = buildTimestampPreset(preset);
  if (!entry) return;
  const target = document.querySelector(
    `#timestampWorkspace input[data-field="${entry.field}"]`,
  );
  if (!target) return;
  target.value = entry.value;
  runTimestampConversion(entry.field, entry.value);
}

function buildTimestampPreset(kind) {
  if (kind !== "now") {
    return null;
  }
  const iso = new Date().toISOString();
  return { field: "iso8601", value: iso };
}

function activateTimestampTool() {
  if (!elements.timestampInputs?.length) return;
  const filled = Array.from(elements.timestampInputs).find((input) =>
    input?.value?.trim(),
  );
  if (filled && filled.dataset.field) {
    runTimestampConversion(filled.dataset.field, filled.value, true);
  } else {
    clearTimestampOutputs();
  }
}

function handleTimestampInput(event) {
  const target = event.target;
  if (!target || state.timestampUpdating) return;
  const field = target.dataset.field;
  if (!field) return;
  const value = target.value || "";
  if (!value.trim()) {
    clearTimestampOutputs();
    return;
  }
  runTimestampConversion(field, value);
}

function runTimestampConversion(field, value, silent = false) {
  if (!state.wasmReady) {
    if (!silent) setStatus("Waiting for WebAssembly...", true);
    return;
  }
  if (!elements.timestampInputs?.length) return;
  try {
    const record = normalizeMapResult(convert_timestamp(field, value));
    state.timestampUpdating = true;
    timestampFields.forEach(({ id, key }) => {
      const input = document.getElementById(id);
      if (!input) return;
      const nextValue = record[key] ?? "";
      input.value = key === field ? nextValue || value : nextValue;
    });
    state.timestampUpdating = false;
    if (!silent) {
      setStatus("Converted timestamp", false);
    }
  } catch (err) {
    state.timestampUpdating = false;
    if (!silent) {
      setStatus(`⚠️ ${err?.message || err}`, true);
    }
  }
}

function clearTimestampOutputs() {
  if (!elements.timestampInputs?.length) return;
  elements.timestampInputs.forEach((input) => {
    input.value = "";
  });
}

function activateTotpTool() {
  if (elements.totpSecret) {
    elements.totpSecret.value = state.totpSecret || "";
  }
  if (elements.totpAlgorithm) {
    elements.totpAlgorithm.value = state.totpAlgorithm || "SHA256";
  }
  if (elements.totpPeriod) {
    elements.totpPeriod.value = state.totpPeriod;
  }
  if (elements.totpDigits) {
    elements.totpDigits.value = state.totpDigits;
  }
  refreshTotp(true);
  stopTotpTimer();
  state.totpTimer = setInterval(() => refreshTotp(true), 1000);
}

function stopTotpTimer() {
  if (state.totpTimer) {
    clearInterval(state.totpTimer);
    state.totpTimer = null;
  }
}

function handleTotpFieldChange() {
  if (elements.totpSecret) {
    state.totpSecret = elements.totpSecret.value || "";
  }
  if (elements.totpAlgorithm) {
    state.totpAlgorithm = elements.totpAlgorithm.value || "SHA256";
  }
  if (elements.totpPeriod) {
    let period = parseInt(elements.totpPeriod.value, 10);
    if (!Number.isFinite(period)) period = 30;
    period = Math.min(Math.max(period, 1), 300);
    state.totpPeriod = period;
    elements.totpPeriod.value = period;
  }
  if (elements.totpDigits) {
    let digits = parseInt(elements.totpDigits.value, 10);
    if (!Number.isFinite(digits)) digits = 6;
    digits = Math.min(Math.max(digits, 4), 10);
    state.totpDigits = digits;
    elements.totpDigits.value = digits;
  }
  refreshTotp();
}

function refreshTotp(silent = false) {
  // Runs RFC 6238 logic in wasm. We refresh every second while the workspace is active.
  if (!elements.totpSecret) return;
  const secret = elements.totpSecret.value || "";
  if (!secret.trim()) {
    renderTotpError("Enter a secret");
    if (!silent) setStatus("Secret is required", true);
    return;
  }
  if (!state.wasmReady) {
    if (!silent) setStatus("Waiting for WebAssembly...", true);
    return;
  }
  try {
    const result = totp_token(
      secret,
      elements.totpAlgorithm?.value || "SHA256",
      state.totpPeriod,
      state.totpDigits,
    );
    renderTotpResult(result);
    if (!silent) setStatus("Generated TOTP code", false);
  } catch (err) {
    renderTotpError(err?.message || String(err));
    if (!silent) setStatus(`⚠️ ${err?.message || err}`, true);
  }
}

function renderTotpResult(result) {
  if (!result) return;
  if (elements.totpCode) {
    elements.totpCode.textContent = result.code || "";
  }
  if (elements.totpPeriodLabel) {
    elements.totpPeriodLabel.textContent = `${result.algorithm || "SHA256"} · every ${result.period || 30}s`;
  }
  if (elements.totpRemainingLabel) {
    elements.totpRemainingLabel.textContent = `${result.remaining || 0}s remaining`;
  }
  if (elements.totpError) {
    elements.totpError.textContent = "";
  }
}

function renderTotpError(message) {
  if (elements.totpCode) {
    elements.totpCode.textContent = "——";
  }
  if (elements.totpError) {
    elements.totpError.textContent = message || "";
  }
  if (elements.totpPeriodLabel) {
    elements.totpPeriodLabel.textContent = "";
  }
  if (elements.totpRemainingLabel) {
    elements.totpRemainingLabel.textContent = "";
  }
}

function copyTotpCode() {
  const value = elements.totpCode?.textContent?.trim();
  if (!value) {
    setStatus("No code to copy", true);
    return;
  }
  copyText(value, "TOTP code");
}

function activateDataTool() {
  if (elements.dataRows) {
    elements.dataRows.value = state.dataRows;
  }
  handleDataSchemaInput();
}

function handleDataRowsChange() {
  getClampedDataRows();
  if (isDataTool(state.currentTool)) {
    markDataDirty("Rows updated. Click Generate to refresh.");
  }
}

function getClampedDataRows() {
  let value = state.dataRows;
  if (elements.dataRows) {
    const parsed = parseInt(elements.dataRows.value, 10);
    if (Number.isFinite(parsed)) {
      value = parsed;
    }
  }
  value = Math.min(Math.max(value || 1, 1), 100);
  state.dataRows = value;
  if (elements.dataRows) {
    elements.dataRows.value = value;
  }
  return value;
}

function handleDataSchemaInput() {
  // Debounce schema parsing to keep typing snappy on large CREATE TABLE blobs.
  if (!elements.dataSchema) return;
  if (!isDataTool(state.currentTool)) return;
  const schema = elements.dataSchema.value || "";
  clearTimeout(state.dataSchemaTimer);
  state.dataSchemaTimer = setTimeout(() => parseDataSchema(schema), 400);
}

function parseDataSchema(schemaText) {
  // Let the wasm helper crunch the schema and mirror whatever it finds in the editor UI.
  if (!state.wasmReady) return;
  const trimmed = schemaText.trim();
  if (!trimmed) {
    state.dataTables = [];
    state.dataOverrides = {};
    state.dataDirty = false;
    renderDataColumnEditor();
    if (elements.dataOutput) elements.dataOutput.value = "";
    return;
  }
  try {
    const tables = inspect_schema(trimmed);
    if (Array.isArray(tables)) {
      state.dataTables = tables;
      pruneDataOverrides();
      renderDataColumnEditor();
      markDataDirty("Schema parsed. Click Generate to refresh.");
    } else {
      state.dataTables = [];
      state.dataDirty = false;
      renderDataColumnEditor();
      setStatus("No tables detected", true);
    }
  } catch (err) {
    console.error(err);
    state.dataDirty = false;
    setStatus(`⚠️ ${err?.message || err}`, true);
  }
}

function pruneDataOverrides() {
  if (!state.dataTables?.length) {
    state.dataOverrides = {};
    return;
  }
  const valid = {};
  state.dataTables.forEach((table) => {
    valid[table.name] = new Set(table.columns.map((col) => col.name));
  });
  Object.keys(state.dataOverrides).forEach((tableName) => {
    if (!valid[tableName]) {
      delete state.dataOverrides[tableName];
      return;
    }
    Object.keys(state.dataOverrides[tableName]).forEach((columnName) => {
      if (!valid[tableName].has(columnName)) {
        delete state.dataOverrides[tableName][columnName];
      }
    });
    if (!Object.keys(state.dataOverrides[tableName]).length) {
      delete state.dataOverrides[tableName];
    }
  });
}

function renderDataColumnEditor() {
  // Rebuild the column cards every time so include/override controls stay aligned with the schema snapshot.
  if (!elements.dataColumnEditor) return;
  if (!state.dataTables?.length) {
    elements.dataColumnEditor.innerHTML =
      '<div class="muted">Paste a schema to configure column ranges.</div>';
    return;
  }
  const groups = state.dataTables
    .map((table) => {
      const cards = table.columns
        .map((column) => renderDataColumnCard(table.name, column))
        .join("");
      return `<div class="data-column-group"><h3>${escapeHTML(table.name)}</h3>${cards}</div>`;
    })
    .join("");
  elements.dataColumnEditor.innerHTML = groups;
}

function renderDataColumnCard(tableName, column) {
  // Numeric fields get min/max/allowed inputs; textual fields surface metadata only.
  const kind = column.kind || "string";
  const overrides = state.dataOverrides?.[tableName]?.[column.name] || {};
  const include = overrides.exclude !== true;
  const disabledAttr = include ? "" : " disabled";
  const cardClass = include ? "data-column-card" : "data-column-card excluded";
  const isNumeric = ["integer", "decimal", "float", "boolean"].includes(kind);
  const defaultValue = column.default_value
    ? escapeHTML(column.default_value)
    : "—";
  const minPlaceholder = column.min_value || "";
  const maxPlaceholder = column.max_value || "";
  const minValue = overrides.min ?? "";
  const maxValue = overrides.max ?? "";
  const allowedValue = overrides.allowed ?? "";
  const controls = isNumeric
    ? `<div class="data-override-row">
        <label>
          <span>Min</span>
          <input type="number" data-table="${escapeAttr(tableName)}" data-column="${escapeAttr(column.name)}" data-field="min" value="${escapeAttr(minValue)}" placeholder="${escapeAttr(minPlaceholder)}"${disabledAttr} />
        </label>
        <label>
          <span>Max</span>
          <input type="number" data-table="${escapeAttr(tableName)}" data-column="${escapeAttr(column.name)}" data-field="max" value="${escapeAttr(maxValue)}" placeholder="${escapeAttr(maxPlaceholder)}"${disabledAttr} />
        </label>
        <label>
          <span>Allowed (comma)</span>
          <input type="text" data-table="${escapeAttr(tableName)}" data-column="${escapeAttr(column.name)}" data-field="allowed" value="${escapeAttr(allowedValue)}" placeholder="e.g. 10,20"${disabledAttr} />
        </label>
      </div>`
    : column.enum_values?.length
      ? `<div class="muted">Enum values: ${escapeHTML(column.enum_values.join(", "))}</div>`
      : '<div class="muted">Text columns use lorem ipsum</div>';
  return `<div class="${cardClass}">
    <header>
      <div class="data-column-header-info">
        <strong>${escapeHTML(column.name)}</strong>
        <span>${escapeHTML(column.data_type || "")}</span>
      </div>
      <label class="data-include-toggle">
        <input type="checkbox" data-table="${escapeAttr(tableName)}" data-column="${escapeAttr(column.name)}" data-field="include" ${include ? "checked" : ""} />
        <span>Include</span>
      </label>
    </header>
    <div class="muted">Default: ${defaultValue}</div>
    ${controls}
  </div>`;
}

function handleDataOverrideInput(event) {
  // Persist override tweaks so Generate can replay the exact same numbers.
  const input = event.target.closest("[data-field]");
  if (!input) return;
  const table = input.dataset.table;
  const column = input.dataset.column;
  const field = input.dataset.field;
  if (!table || !column || !field) return;
  if (!state.dataOverrides[table]) state.dataOverrides[table] = {};
  if (!state.dataOverrides[table][column])
    state.dataOverrides[table][column] = {};
  const entry = state.dataOverrides[table][column];
  if (field === "include") {
    const include = input.checked !== false;
    if (!include) {
      entry.exclude = true;
    } else {
      delete entry.exclude;
    }
    cleanupDataOverrideEntry(table, column);
    syncDataColumnCardState(input.closest(".data-column-card"), include);
    markDataDirty("Column selection updated. Click Generate to refresh.");
    return;
  }
  const value = input.value || "";
  if (!value.trim()) {
    delete entry[field];
  } else {
    entry[field] = value;
  }
  cleanupDataOverrideEntry(table, column);
  markDataDirty("Overrides updated. Click Generate to refresh.");
}

function cleanupDataOverrideEntry(table, column) {
  if (!state.dataOverrides[table]) return;
  if (
    column &&
    state.dataOverrides[table][column] &&
    !Object.keys(state.dataOverrides[table][column]).length
  ) {
    delete state.dataOverrides[table][column];
  }
  if (!Object.keys(state.dataOverrides[table]).length) {
    delete state.dataOverrides[table];
  }
}

function markDataDirty(message) {
  state.dataDirty = true;
  if (message && isDataTool(state.currentTool)) {
    setStatus(message, false);
  }
}

function syncDataColumnCardState(card, include) {
  if (!card) return;
  card.classList.toggle("excluded", !include);
  const inputs = card.querySelectorAll(
    'input[data-field]:not([data-field="include"])',
  );
  inputs.forEach((el) => {
    el.disabled = !include;
  });
}

function buildDataOverrides() {
  const overrides = {};
  Object.entries(state.dataOverrides || {}).forEach(([tableName, columns]) => {
    const tableOverrides = {};
    Object.entries(columns).forEach(([columnName, config]) => {
      const entry = {};
      if (config.exclude === true) {
        entry.exclude = true;
      }
      const min = parseFloat(config.min);
      if (Number.isFinite(min)) entry.min = min;
      const max = parseFloat(config.max);
      if (Number.isFinite(max)) entry.max = max;
      const allowed = parseAllowedNumbers(config.allowed);
      if (allowed.length) entry.allowed = allowed;
      if (Object.keys(entry).length) {
        tableOverrides[columnName] = entry;
      }
    });
    if (Object.keys(tableOverrides).length) {
      overrides[tableName] = tableOverrides;
    }
  });
  return overrides;
}

function parseAllowedNumbers(value) {
  if (!value) return [];
  return value
    .split(",")
    .map((part) => parseFloat(part.trim()))
    .filter((num) => Number.isFinite(num));
}

function runDataGenerator() {
  if (!isDataTool(state.currentTool)) {
    setStatus("Select the SQL Inserts tool", true);
    return;
  }
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
    return;
  }
  if (!elements.dataSchema) return;
  const rows = getClampedDataRows();
  const schema = elements.dataSchema.value || "";
  if (!schema.trim()) {
    setStatus("Schema is empty", true);
    state.dataDirty = false;
    return;
  }
  if (state.dataSchemaTimer) {
    clearTimeout(state.dataSchemaTimer);
    state.dataSchemaTimer = null;
    parseDataSchema(schema);
  } else if (!state.dataTables?.length) {
    parseDataSchema(schema);
  }
  if (!state.dataTables?.length) {
    setStatus("No tables detected", true);
    return;
  }
  try {
    const overrides = buildDataOverrides();
    const result = generate_insert_statements(schema, rows, overrides) || "";
    if (elements.dataOutput) {
      elements.dataOutput.value = result;
    }
    state.dataDirty = false;
    setStatus("Generated INSERT statements", false);
  } catch (err) {
    console.error(err);
    setStatus(`⚠️ ${err?.message || err}`, true);
    if (elements.dataOutput) {
      elements.dataOutput.value = "";
    }
  }
}

function copyDataOutput() {
  const value = elements.dataOutput?.value || "";
  if (!value.trim()) {
    setStatus("No INSERT statements to copy", true);
    return;
  }
  copyText(value, "INSERT statements");
  setStatus("Copied", false);
}

function activateKdfTool() {
  seedKdfInputs();
  setKdfAlgorithm(state.kdf.active || "bcrypt");
  clearKdfStatuses();
  if (!state.wasmReady) {
    setStatus("Waiting for WebAssembly...", true);
  } else {
    setStatus("Ready", false);
  }
}

function refreshKdfSalts() {
  seedKdfInputs(true);
  setStatus("已重新產生鹽值", false);
}

function setKdfAlgorithm(algo) {
  state.kdf.active = algo;
  if (elements.kdfAlgoSelect) {
    elements.kdfAlgoSelect.value = algo;
  }
  const cards = elements.kdfCards || [];
  cards.forEach((card) => {
    const match = card.dataset.algo === algo;
    card.classList.toggle("hidden", !match);
  });
}

function seedKdfInputs(forceSalt = false) {
  // Keep both Argon2 and Bcrypt salts populated; button click forces regeneration.
  if (elements.argonSalt) {
    if (forceSalt || !elements.argonSalt.value.trim()) {
      state.kdf.salts.argon = randomSaltBase64(16);
      elements.argonSalt.value = state.kdf.salts.argon;
    } else {
      state.kdf.salts.argon = elements.argonSalt.value.trim();
    }
  }
  if (elements.bcryptSalt) {
    if (forceSalt || !elements.bcryptSalt.value.trim()) {
      state.kdf.salts.bcrypt = randomBcryptSalt();
      elements.bcryptSalt.value = state.kdf.salts.bcrypt;
    } else {
      state.kdf.salts.bcrypt = elements.bcryptSalt.value.trim();
    }
  }
}

// KDF flows:
// - Hash: uses wasm functions to generate hashes. Output field stays editable so users can tweak/replace.
// - Verify: if input starts with scheme ($2... or $argon2...), verify via wasm; otherwise treat input as plain text and compare to password (utility for quick equality checks like "apple111").
// - Salts: empty salt triggers secure random generation; "Random salt" button clears bcrypt salt and regenerates Argon2/S crypt salts.
async function runBcryptHash() {
  if (!state.wasmReady) {
    setKdfStatus("bcryptStatus", "Wasm not loaded", true);
    return;
  }
  const password = readPassword(elements.bcryptPassword, "bcryptStatus");
  if (!password) return;
  const cost = clampNumber(elements.bcryptCost?.value, 4, 31, state.kdf.bcryptCost);
  state.kdf.bcryptCost = cost;
  if (elements.bcryptCost) elements.bcryptCost.value = cost;
  try {
    setKdfStatus("bcryptStatus", "產生中…");
    const saltInput = getInputValue(elements.bcryptSalt);
    const hash = await bcrypt_hash(password, cost, saltInput || undefined);
    if (elements.bcryptSalt) {
      const salt = bcryptSaltFromHash(hash);
      if (salt) elements.bcryptSalt.value = salt;
    }
    if (elements.bcryptOutput) elements.bcryptOutput.value = hash || "";
    if (elements.bcryptVerifyHash) {
      elements.bcryptVerifyHash.value = hash || "";
    }
    setKdfStatus("bcryptStatus", "Hash generated", "ok");
  } catch (err) {
    console.error(err);
    setKdfStatus("bcryptStatus", err?.message || "Generate failed", true);
  }
}

async function verifyBcrypt() {
  if (!state.wasmReady) {
    setKdfStatus("bcryptStatus", "Wasm not loaded", true);
    return;
  }
  const password = readPassword(elements.bcryptPassword, "bcryptStatus");
  const verifyInput = getInputValue(elements.bcryptVerifyHash);
  const outputHash = getInputValue(elements.bcryptOutput);
  const hash = verifyInput || outputHash;

  // If password is empty, allow direct comparison between the two lower fields.
  if (!password) {
    if (!verifyInput || !outputHash) {
      setKdfStatus("bcryptStatus", "Fill both fields to compare", true);
      setStatus("Fill both fields to compare", true);
      return;
    }
    let ok = false;
    const topIsHash = outputHash.startsWith("$2");
    const bottomIsHash = verifyInput.startsWith("$2");
    if (topIsHash && bottomIsHash) {
      // Both are hashes; direct equality
      ok = verifyInput === outputHash;
    } else if (topIsHash) {
      // Top is hash, bottom plain
      ok = await bcrypt_verify(verifyInput, outputHash);
    } else if (bottomIsHash) {
      // Bottom is hash, top plain
      ok = await bcrypt_verify(outputHash, verifyInput);
    } else {
      // both plain strings
      ok = verifyInput === outputHash;
    }
    setKdfStatus("bcryptStatus", ok ? "Match" : "Mismatch", ok ? "ok" : true);
    setStatus(ok ? "Match" : "Mismatch", !ok);
    return;
  }

  if (!hash) {
    setKdfStatus("bcryptStatus", "Please paste or generate a bcrypt hash", true);
    return;
  }
  try {
    setKdfStatus("bcryptStatus", "Verifying…");
    let ok = false;
    if (hash.startsWith("$2")) {
      ok = await bcrypt_verify(password, hash);
    } else {
      ok = hash === password;
    }
    setKdfStatus("bcryptStatus", ok ? "Match" : "Mismatch", ok ? "ok" : true);
  } catch (err) {
    console.error(err);
    setKdfStatus("bcryptStatus", err?.message || "Verify failed", true);
  }
}

async function runArgonHash() {
  if (!state.wasmReady) {
    setKdfStatus("argonStatus", "Wasm not loaded", true);
    return;
  }
  const password = readPassword(elements.argonPassword, "argonStatus");
  if (!password) {
    setKdfStatus("argonStatus", "Please enter password", true);
    return;
  }
  const time = clampNumber(elements.argonTime?.value, 1, 12, state.kdf.argonTime);
  const mem = clampNumber(elements.argonMem?.value, 4096, 1048576, state.kdf.argonMem);
  const parallelism = clampNumber(elements.argonParallelism?.value, 1, 8, state.kdf.argonParallelism);
  const hashLen = clampNumber(elements.argonHashLen?.value, 8, 128, state.kdf.argonHashLen);
  state.kdf.argonTime = time;
  state.kdf.argonMem = mem;
  state.kdf.argonParallelism = parallelism;
  state.kdf.argonHashLen = hashLen;
  const saltInput = getInputValue(elements.argonSalt);
  const salt = saltInput || randomSaltBase64(16);
  if (!saltInput && elements.argonSalt) elements.argonSalt.value = salt;
  try {
    setKdfStatus("argonStatus", "Generating…");
    const variant = elements.argonType?.value || "argon2id";
    const encoded = await argon2_hash(password, salt, time, mem, parallelism, hashLen, variant);
    if (elements.argonOutput) elements.argonOutput.value = encoded || "";
    if (elements.argonVerifyHash) {
      elements.argonVerifyHash.value = encoded || "";
    }
    setKdfStatus("argonStatus", "Hash generated", "ok");
  } catch (err) {
    console.error(err);
    setKdfStatus("argonStatus", err?.message || "Generate failed", true);
  }
}

async function verifyArgon() {
  if (!state.wasmReady) {
    setKdfStatus("argonStatus", "Wasm not loaded", true);
    return;
  }
  const password = readPassword(elements.argonPassword, "argonStatus");
  const verifyInput = getInputValue(elements.argonVerifyHash);
  const outputHash = getInputValue(elements.argonOutput);
  const encoded = verifyInput || outputHash;

  if (!password) {
    if (!verifyInput || !outputHash) {
      setKdfStatus("argonStatus", "Fill both fields to compare", true);
      setStatus("Fill both fields to compare", true);
      return;
    }
    let ok = false;
    const topIsHash = outputHash.startsWith("$argon2");
    const bottomIsHash = verifyInput.startsWith("$argon2");
    if (topIsHash && bottomIsHash) {
      ok = verifyInput === outputHash;
    } else if (topIsHash) {
      ok = await argon2_verify(verifyInput, outputHash);
    } else if (bottomIsHash) {
      ok = await argon2_verify(outputHash, verifyInput);
    } else {
      ok = verifyInput === outputHash;
    }
    setKdfStatus("argonStatus", ok ? "Match" : "Mismatch", ok ? "ok" : true);
    setStatus(ok ? "Match" : "Mismatch", !ok);
    return;
  }

  if (!encoded) {
    setKdfStatus("argonStatus", "Please paste or generate Argon2 PHC string", true);
    return;
  }
  try {
    setKdfStatus("argonStatus", "Verifying…");
    let ok = false;
    if (encoded.startsWith("$argon2")) {
      ok = await argon2_verify(password, encoded);
    } else {
      ok = encoded === password;
    }
    setKdfStatus("argonStatus", ok ? "Match" : "Mismatch", ok ? "ok" : true);
  } catch (err) {
    console.error(err);
    setKdfStatus("argonStatus", err?.message || "Verify failed", true);
  }
}

function setKdfStatus(key, message, intent = "") {
  const el = elements[key];
  if (!el) return;
  el.textContent = message;
  el.classList.remove("ok", "error");
  if (intent === "ok") el.classList.add("ok");
  else if (intent) el.classList.add("error");
}

function clearKdfStatuses() {
  setKdfStatus("bcryptStatus", "Idle");
  setKdfStatus("argonStatus", "Idle");
}

function getInputValue(el) {
  return el?.value?.trim() || "";
}

function readPassword(el, statusKey) {
  const value = el?.value || "";
  return value;
}

function clampNumber(value, min, max, fallback) {
  const num = Number(value);
  if (!Number.isFinite(num)) return fallback;
  return Math.min(max, Math.max(min, num));
}

function clampToPowerOfTwo(value, min, max, fallback) {
  let num = clampNumber(value, min, max, fallback || min);
  num = 2 ** Math.round(Math.log2(num));
  if (num < min) num = min;
  if (num > max) num = max;
  return num;
}

function base64ToBytes(b64) {
  try {
    const bin = atob(b64 || "");
    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i += 1) bytes[i] = bin.charCodeAt(i);
    return bytes;
  } catch (err) {
    return new Uint8Array();
  }
}

function bytesToBase64(bytes) {
  let binary = "";
  for (let i = 0; i < bytes.length; i += 1) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}

function utf8ToBytes(text) {
  if (typeof TextEncoder !== "undefined") return new TextEncoder().encode(text);
  const bytes = new Uint8Array(text.length);
  for (let i = 0; i < text.length; i += 1) bytes[i] = text.charCodeAt(i);
  return bytes;
}

function randomSaltBase64(byteLength = 16) {
  const arr = new Uint8Array(byteLength);
  crypto.getRandomValues(arr);
  return bytesToBase64(arr);
}

function randomBcryptSalt(byteLength = 16) {
  const arr = new Uint8Array(byteLength);
  crypto.getRandomValues(arr);
  const std = bytesToBase64(arr).replace(/=+$/g, "");
  // Bcrypt uses crypt-base64 alphabet: ./A-Za-z0-9
  return std.replace(/\+/g, ".").replace(/\//g, "/");
}

function bcryptSaltFromHash(hash) {
  if (!hash || !hash.startsWith("$")) return "";
  const parts = hash.split("$");
  if (parts.length < 4) return "";
  const saltAndHash = parts[3] || "";
  return saltAndHash.slice(0, 22);
}

function sanitizeRandomExclude(value) {
  if (!value) return "";
  const compact = value.replace(/\s+/g, "");
  if (!compact) return "";
  const seen = new Set();
  let result = "";
  for (const ch of compact) {
    if (!seen.has(ch)) {
      seen.add(ch);
      result += ch;
    }
  }
  return result;
}

async function copyText(value, label) {
  try {
    await navigator.clipboard.writeText(value);
    setStatus(`Copied ${label}`, false);
  } catch (err) {
    console.error(err);
    setStatus("Unable to access clipboard", true);
  }
}

function escapeHTML(value = "") {
  return value
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;");
}

function escapeAttr(value = "") {
  return escapeHTML(value).replace(/'/g, "&#39;");
}

function normalizeUuidResult(value) {
  return normalizeMapResult(value);
}

function normalizeMapResult(value) {
  if (!value) {
    return {};
  }
  if (value instanceof Map) {
    const record = {};
    value.forEach((val, key) => {
      record[String(key)] = typeof val === "string" ? val : String(val ?? "");
    });
    return record;
  }
  if (typeof value === "object" && !Array.isArray(value)) {
    const record = {};
    Object.keys(value).forEach((key) => {
      const val = value[key];
      record[key] = typeof val === "string" ? val : String(val ?? "");
    });
    return record;
  }
  return {};
}

function capitalize(text) {
  if (!text) return "";
  return text.charAt(0).toUpperCase() + text.slice(1);
}
